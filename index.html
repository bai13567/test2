<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Trinity Neon Background</title>
<style>
html,body{margin:0;height:100%;background:#06070b;overflow:hidden;font:12px ui-monospace,Menlo,Consolas,monospace}
#c{position:fixed;inset:0;display:block}
#ui{position:fixed;left:12px;right:12px;top:12px;z-index:9;display:flex;gap:10px;align-items:center;justify-content:space-between;
padding-top:env(safe-area-inset-top);pointer-events:none}
#pill{flex:1;min-width:0;padding:10px 12px;border-radius:14px;border:1px solid #7af5;background:linear-gradient(90deg,#1a2bff22,#ff2bd722);
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset,0 14px 40px #000b;color:#d7e3ff;mix-blend-mode:screen;
text-shadow:0 0 14px #7af,0 0 30px #f0f}
#pill b{color:#fff}#pill small{display:block;opacity:.85;margin-top:6px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.btn{pointer-events:auto;padding:10px 12px;border-radius:14px;border:1px solid #fff2;background:#0006;color:#fff;backdrop-filter:blur(12px);
box-shadow:0 0 0 1px #fff1 inset}
.btn:active{transform:translateY(1px)}
body:before{content:"";position:fixed;inset:-60px;pointer-events:none;background:
repeating-linear-gradient(0deg,rgba(255,255,255,.045),rgba(255,255,255,.045) 1px,transparent 2px,transparent 5px);
mix-blend-mode:overlay;opacity:.28;animation:scan 7s linear infinite}
@keyframes scan{to{transform:translateY(60px)}}
</style>

<canvas id="c"></canvas>
<div id="ui">
  <div id="pill"><b>TRINITY NEON</b> · <span id="s">mode 1</span>
    <small>每分钟自动切换 · 只显示当前模式按钮（点一下切到下一套）</small>
  </div>
  <button id="b1" class="btn">BUTTON 1</button>
  <button id="b2" class="btn" style="display:none">BUTTON 2</button>
  <button id="b3" class="btn" style="display:none">BUTTON 3</button>
</div>

<script>
(()=>{ "use strict";
const c=document.getElementById("c"),C=c.getContext("2d",{alpha:false}),S=document.getElementById("s");
const b1=document.getElementById("b1"),b2=document.getElementById("b2"),b3=document.getElementById("b3");
const clamp=(x,a,b)=>x<a?a:x>b?b:x, TAU=Math.PI*2;
const mobile=matchMedia("(pointer:coarse)").matches||innerWidth<760;

// 低分辨率“伪shader”画布（再放大）：iOS 更稳也更省
const oc=document.createElement("canvas"),O=oc.getContext("2d",{alpha:false});
let W=0,H=0,dpr=1,res=mobile?240:300,mode=0,boom=0,t=0,last=performance.now(),ema=60;
let timer=null;

function resize(){
  dpr=clamp(devicePixelRatio||1,1,mobile?1.6:2.0);
  W=innerWidth;H=innerHeight;
  c.width=W*dpr; c.height=H*dpr;
  // 根据屏幕大小动态选采样分辨率（越大越精致，但会更耗）
  res=clamp((Math.min(W,H)*(mobile?0.55:0.7))|0,200,380);
  oc.width=res; oc.height=res;
}
addEventListener("resize",resize,{passive:true}); resize();

function showButtons(){
  b1.style.display=mode===0?"":"none";
  b2.style.display=mode===1?"":"none";
  b3.style.display=mode===2?"":"none";
  S.textContent="mode "+(mode+1);
}
showButtons();

function resetMinuteAuto(){
  if(timer) clearInterval(timer);
  timer=setInterval(()=>setMode((mode+1)%3,false),60*1000);
}
resetMinuteAuto();

function setMode(m,manual=true){
  mode=m|0; boom=1; showButtons();
  if(manual) resetMinuteAuto();
}

// 少量按钮交互：每套只显示自己的按钮，点一下切到下一套
b1.onclick=()=>setMode(1,true);
b2.onclick=()=>setMode(2,true);
b3.onclick=()=>setMode(0,true);

// 颜色工具
function hsv(h,s,v){
  h=(h%1+1)%1;
  let i=(h*6)|0,f=h*6-i,p=v*(1-s),q=v*(1-f*s),t=v*(1-(1-f)*s);
  switch(i%6){case 0:return [v,t,p];case 1:return [q,v,p];case 2:return [p,v,t];
    case 3:return [p,q,v];case 4:return [t,p,v];default:return [v,p,q];}
}

// 三套背景：每帧生成 res*res 的像素，再放大 + 后处理
function renderMode0(tt){ // Neon Vortex
  const img=O.getImageData(0,0,res,res),d=img.data;
  let i=0; for(let y=0;y<res;y++){let v=y/(res-1)*2-1;
    for(let x=0;x<res;x++){
      let u=x/(res-1)*2-1;
      let r=Math.hypot(u,v),a=Math.atan2(v,u);
      let w=Math.exp(-r*2.8);
      let z=Math.sin(r*10-tt*2.0)+Math.sin(a*6+tt*0.9)+Math.cos(u*4-tt*0.6)*0.6;
      z=(z+2.6)/5.2;
      let h=0.62+0.22*z+0.05*Math.sin(tt*0.2);
      let rgb=hsv(h,1,0.22+0.85*(0.15+0.85*z)+w*0.35+boom*0.12);
      d[i++]=(rgb[0]*255)|0; d[i++]=(rgb[1]*255)|0; d[i++]=(rgb[2]*255)|0; d[i++]=255;
  }}
  O.putImageData(img,0,0);
}
function renderMode1(tt){ // Aurora + Mist
  const img=O.getImageData(0,0,res,res),d=img.data;
  let i=0; for(let y=0;y<res;y++){let v=y/(res-1);
    for(let x=0;x<res;x++){
      let u=x/(res-1);
      let X=(u-0.5)*2, Y=(v-0.5)*2;
      let band=Math.sin((X*1.2+tt*0.12)*3)+Math.cos((Y*1.6-tt*0.10)*2.2);
      let aur=Math.sin((Y*2.2+Math.sin(tt*0.2)*0.4)*6+tt*0.9+band*1.4);
      let fog=Math.exp(-Math.abs(Y)*1.8)*(0.35+0.65*Math.sin(tt*0.25+X*2)*0.5+0.5);
      let z=(aur*0.5+0.5); z=z*z;
      let h=0.43+0.18*z+0.02*Math.sin(tt*0.15);
      let v1=0.12+0.95*(z*0.9+fog*0.35)+boom*0.12;
      let rgb=hsv(h,0.95,v1);
      // 冷暖边缘
      let edge=Math.exp(-Math.abs(X)*2.2)*0.10;
      d[i++]=((rgb[0]+edge)*255)|0; d[i++]=((rgb[1]+edge*0.7)*255)|0; d[i++]=((rgb[2]+edge*1.4)*255)|0; d[i++]=255;
  }}
  O.putImageData(img,0,0);
}
function renderMode2(tt){ // Star Warp + Fractal Pulse
  const img=O.getImageData(0,0,res,res),d=img.data;
  let i=0; for(let y=0;y<res;y++){let v=y/(res-1)*2-1;
    for(let x=0;x<res;x++){
      let u=x/(res-1)*2-1;
      let r=Math.hypot(u,v)+1e-4, a=Math.atan2(v,u);
      // 旋涡分形感
      let k=Math.sin(a*5+tt*0.8)+Math.cos(r*8-tt*1.6);
      let f=Math.sin((u*k+tt*0.12)*5)+Math.cos((v-k-tt*0.1)*4);
      let z=(f+2)/4; z=z*z;
      // 星点：用 hash-like 的格点闪烁
      let sx=((u*0.5+0.5)*res)|0, sy=((v*0.5+0.5)*res)|0;
      let hsh=Math.sin((sx*12.9898+sy*78.233))*43758.5453; hsh=hsh-Math.floor(hsh);
      let star=(hsh>0.996?1:0)* (0.55+0.45*Math.sin(tt*6+hsh*9));
      let warp=Math.exp(-r*1.7)*(0.25+0.75*(0.5+0.5*Math.sin(tt*1.1-r*14)));
      let base=0.08+0.85*(z*0.7+warp*0.55)+star*0.9+boom*0.14;
      let h=0.80-0.25*z;
      let rgb=hsv(h,1,base);
      d[i++]=(rgb[0]*255)|0; d[i++]=(rgb[1]*255)|0; d[i++]=(rgb[2]*255)|0; d[i++]=255;
  }}
  O.putImageData(img,0,0);
}

function draw(now){
  requestAnimationFrame(draw);
  const dt=now-last; last=now;
  const fps=1000/(dt||16.7); ema=ema*0.92+fps*0.08;

  t+=dt*0.001*(1+(boom?1.8:0)); boom&&=(boom*=0.88)<0.02?0:boom;

  // 质量自适应：iOS 上也尽量稳（只调 res，不动 canvas 尺寸）
  if(ema<52 && res>210){res=(res*0.97)|0; oc.width=oc.height=res;}
  if(ema>58 && res<(mobile?300:380)){res=(res*1.01)|0; oc.width=oc.height=res;}

  if(mode===0) renderMode0(t);
  else if(mode===1) renderMode1(t);
  else renderMode2(t);

  // 主画布：放大 + “伪 bloom/余晖/轻微故障”
  C.setTransform(dpr,0,0,dpr,0,0);
  C.imageSmoothingEnabled=true;
  C.globalCompositeOperation="source-over";
  C.drawImage(oc,0,0,W,H);

  // Bloom：叠加两次模糊（iOS 支持 canvas filter）
  C.globalCompositeOperation="screen";
  C.globalAlpha=0.26+(boom?0.10:0);
  C.filter="blur(10px)";
  C.drawImage(c,0,0,W*dpr,H*dpr,0,0,W,H);
  C.filter="blur(24px)";
  C.globalAlpha=0.16+(boom?0.08:0);
  C.drawImage(c,0,0,W*dpr,H*dpr,0,0,W,H);
  C.filter="none";
  C.globalAlpha=1;

  // 轻微故障抖动（很克制，避免 iOS 发热）
  if(((t*10)|0)%28===0){
    C.globalAlpha=0.07;
    C.drawImage(c,(Math.random()-.5)*10*dpr,(Math.random()-.5)*6*dpr);
    C.globalAlpha=1;
  }

  // 状态文字（别太频繁更新）
  if(((t*4)|0)%2===0) S.textContent=`mode ${mode+1} · fps~${ema.toFixed(0)} · res=${res}px · auto: 60s`;
}
requestAnimationFrame(draw);
})();
</script>