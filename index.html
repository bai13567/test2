<!doctype html>
<html lang="zh">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>White Clouds (iOS Safari)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#eef6ff}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}
</style>
<canvas id="c"></canvas>

<script>
(()=> {
  const c=document.getElementById("c");
  const gl=c.getContext("webgl",{antialias:false,alpha:false}) || c.getContext("experimental-webgl",{antialias:false,alpha:false});
  if(!gl){
    const g=c.getContext("2d"); if(!g) return;
    g.fillStyle="#000"; g.font="16px system-ui";
    g.fillText("WebGL not supported",20,30);
    return;
  }

  const V=`attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}`;
  const F=`precision highp float;
uniform vec2 r; uniform float t;

float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
float noise(vec2 p){
  vec2 i=floor(p), f=fract(p); f=f*f*(3.-2.*f);
  float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
  return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
}
float fbm(vec2 p){
  float v=0., a=.55;
  for(int i=0;i<6;i++){ v+=a*noise(p); p=p*2.02+17.3; a*=.5; }
  return v;
}
vec2 flow(vec2 p){
  float e=.08;
  float n1=fbm(p+vec2(0,e));
  float n2=fbm(p-vec2(0,e));
  float n3=fbm(p+vec2(e,0));
  float n4=fbm(p-vec2(e,0));
  return vec2(n1-n2, n4-n3);
}

void main(){
  vec2 uv = gl_FragCoord.xy / r;
  vec2 p = uv*2.0 - 1.0;
  p.x *= r.x / r.y;

  float tt = t*0.03;
  vec2 baseDrift = vec2(tt*1.05, tt*0.62);

  // 下厚上薄
  float h = clamp((p.y+1.0)*0.5, 0.0, 1.0);
  float layer = mix(1.18, 0.80, h);

  vec2 q = p*0.95*layer;

  // 卷动流场（避免贴图平移感）
  vec2 f1 = flow(q*1.2 + baseDrift*0.8);
  vec2 f2 = flow(q*2.0 - baseDrift*1.1);
  q += 0.20*f1 + 0.08*f2;

  // 三段频率：形体/细节/边缘纤维
  float shape  = fbm(q*0.75 + baseDrift*0.6);
  float detail = fbm(q*1.8  - baseDrift*1.0);
  float wisps  = fbm(q*3.6  + baseDrift*1.4);

  // ⭐ 云量：把 cover 调低一点，云更容易“出现”
  float cover = mix(0.49, 0.58, 1.0-h); // 原来更高，会太稀
  float base = shape - cover;

  // 云 mask + 边缘带
  float m    = smoothstep(-0.10, 0.20, base);
  float edge = smoothstep(0.20, -0.06, abs(base));

  // ⭐ 密度：整体增强一点，边缘纤维只加在边界
  float dens = m * (0.62 + 0.38*detail);
  dens += edge * 0.26 * (wisps-0.5);
  dens = clamp(dens, 0.0, 1.0);
  dens = clamp(dens*1.20, 0.0, 1.0);   // ⭐ 关键：云更“厚”

  // 光照：上方光源
  vec2 L = normalize(vec2(-0.45, 0.90));
  float e=0.0035;
  float dx = (fbm((q+vec2(e,0))*0.9 + baseDrift*0.6) - fbm((q-vec2(e,0))*0.9 + baseDrift*0.6));
  float dy = (fbm((q+vec2(0,e))*0.9 + baseDrift*0.6) - fbm((q-vec2(0,e))*0.9 + baseDrift*0.6));
  vec3 N = normalize(vec3(-dx*2.2, -dy*2.2, 1.0));
  float ndl = clamp(dot(N, vec3(L, 0.6)), 0.0, 1.0);

  // Beer-Lambert：厚处更暗更实体
  float thick = dens*dens;
  float trans = exp(-2.45*thick);

  // 银边：边缘更亮一点点
  float rim = pow(1.0 - clamp(dot(N, vec3(0,0,1)), 0.0, 1.0), 2.0);
  float silver = rim * edge * (0.40 + 0.60*ndl);

  // ⭐ 天空略压一点（iOS 很容易把浅色吃掉云对比）
  vec3 skyTop = vec3(0.80, 0.90, 1.00);
  vec3 skyBot = vec3(0.92, 0.955, 1.00);
  vec3 sky = mix(skyBot, skyTop, smoothstep(-1.0, 1.0, p.y));
  sky = mix(sky, vec3(0.975,0.985,1.0), 0.06*(1.0-h));

  // 云颜色：亮部暖、阴影冷（对比稍加）
  vec3 warm = vec3(1.00, 0.99, 0.975);
  vec3 cool = vec3(0.78, 0.86, 0.98);
  vec3 cloudLit = mix(cool, warm, 0.30 + 0.70*ndl);

  // ⭐ alpha 提升：让云更明显，但不“糊一片白”
  float alpha = clamp(dens*1.55, 0.0, 1.0);

  vec3 col = mix(sky, cloudLit, alpha*(0.78 + 0.22*(1.0-trans)));
  col = mix(col, vec3(1.0), 0.22*silver);

  // 轻微对比（避免灰）
  col = clamp(col, 0.0, 1.0);
  col = pow(col, vec3(0.97));
  gl_FragColor = vec4(col, 1.0);
}`;

  function sh(type,src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  }
  const P=gl.createProgram();
  gl.attachShader(P,sh(gl.VERTEX_SHADER,V));
  gl.attachShader(P,sh(gl.FRAGMENT_SHADER,F));
  gl.linkProgram(P);
  if(!gl.getProgramParameter(P,gl.LINK_STATUS)) throw gl.getProgramInfoLog(P);
  gl.useProgram(P);

  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]),gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(P,"p");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  const ur=gl.getUniformLocation(P,"r");
  const ut=gl.getUniformLocation(P,"t");

  function resize(){
    const d=Math.min(2,devicePixelRatio||1);
    const vw=visualViewport?visualViewport.width:innerWidth;
    const vh=visualViewport?visualViewport.height:innerHeight;
    c.width=Math.max(1,Math.floor(vw*d));
    c.height=Math.max(1,Math.floor(vh*d));
    gl.viewport(0,0,c.width,c.height);
    gl.uniform2f(ur,c.width,c.height);
  }
  addEventListener("resize",resize,{passive:true});
  visualViewport && visualViewport.addEventListener("resize",resize,{passive:true});
  resize();

  let t0=performance.now(), paused=false;
  document.addEventListener("visibilitychange",()=>paused=document.hidden,{passive:true});

  (function loop(now){
    if(!paused){
      gl.uniform1f(ut,(now-t0)/1000);
      gl.drawArrays(gl.TRIANGLES,0,6);
    }
    requestAnimationFrame(loop);
  })(t0);
})();
</script>
</html>