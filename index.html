<!doctype html>
<html lang="zh">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Volumetric Clouds with Advanced Techniques</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    overflow: hidden;
    background: #eef6ff;
  }
  canvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    touch-action: none;
  }
</style>
<canvas id="c"></canvas>

<script>
(() => {
  const c = document.getElementById("c");
  const gl = c.getContext("webgl", { antialias: true, alpha: false });
  if (!gl) {
    const g = c.getContext("2d");
    if (!g) return;
    g.fillStyle = "#000";
    g.font = "16px system-ui";
    g.fillText("WebGL not supported", 20, 30);
    return;
  }

  const V = `attribute vec2 p;
    void main() {
      gl_Position = vec4(p, 0.0, 1.0);
    }`;

  const F = `precision highp float;
  uniform vec2 r;
  uniform float t;

  // ----------------- Hash & Noise -----------------
  float hash11(float n){ return fract(sin(n)*43758.5453123); }
  float hash31(vec3 p){ return hash11(dot(p, vec3(127.1,311.7,74.7))); }
  float noise3(vec3 p){
    vec3 i = floor(p), f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float n000 = hash31(i + vec3(0, 0, 0));
    float n100 = hash31(i + vec3(1, 0, 0));
    float n010 = hash31(i + vec3(0, 1, 0));
    float n110 = hash31(i + vec3(1, 1, 0));
    float n001 = hash31(i + vec3(0, 0, 1));
    float n101 = hash31(i + vec3(1, 0, 1));
    float n011 = hash31(i + vec3(0, 1, 1));
    float n111 = hash31(i + vec3(1, 1, 1));
    float nx00 = mix(n000, n100, f.x);
    float nx10 = mix(n010, n110, f.x);
    float nx01 = mix(n001, n101, f.x);
    float nx11 = mix(n011, n111, f.x);
    float nxy0 = mix(nx00, nx10, f.y);
    float nxy1 = mix(nx01, nx11, f.y);
    return mix(nxy0, nxy1, f.z);
  }

  // ----------------- Cloud Density Field -----------------
  float fbm3(vec3 p){
    float v = 0.0, a = 0.58;
    for (int i = 0; i < 6; i++) {
      v += a * noise3(p);
      p = p * 2.02 + vec3(19.7, 7.3, 11.1);
      a *= 0.52;
    }
    return v;
  }

  // Cloud Density Function with Height Influence
  float cloudField(vec3 P){
    float base = fbm3(P * 0.55);
    float detail = fbm3(P * 2.2);
    vec3 warp = vec3(
      fbm3(P * 1.1 + 10.0),
      fbm3(P * 1.1 + 30.0),
      fbm3(P * 1.1 + 50.0)
    );
    P += (warp - 0.5) * 0.55;
    float d = base * 0.78 + detail * 0.22;
    d = smoothstep(0.48, 0.78, d);
    d = pow(d, 1.35);
    return d;
  }

  // ----------------- Multiple Scattering Approximation -----------------
  vec3 multiScatterApprox(vec3 single, float density, float TrL){
    float ms = 1.0 - exp(-density * 2.5);
    return single * (1.0 + ms * 0.6) * (0.7 + 0.3 * TrL);
  }

  // ----------------- Light and Shadow -----------------
  float lightTransmittance(vec3 p, vec3 L){
    float Tr = 1.0;
    const int LS = 24;
    float stepLen = 0.085;
    for (int i = 0; i < LS; i++) {
      p += L * stepLen;
      float d = cloudField(p);
      Tr *= exp(-d * 1.35 * stepLen * 6.5);
      if (Tr < 0.02) break;
    }
    return clamp(Tr, 0.0, 1.0);
  }

  // ----------------- Tone Mapping -----------------
  vec3 tonemap(vec3 x){
    x = max(x, vec3(0.0));
    return (x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14);
  }

  void main(){
    vec2 uv = gl_FragCoord.xy / r;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= r.x / r.y;

    // Camera setup
    vec3 ro = vec3(0.0, 0.15, 2.35);
    vec3 rd = normalize(vec3(p.x, p.y * 0.92, -1.55));

    // Wind and Cloud Offset
    float tt = t * 0.045;
    vec3 wind = vec3(tt * 0.60, tt * 0.22, tt * 0.38);

    // Sunlight Direction
    vec3 sunDir = normalize(vec3(0.65, 0.45, -0.35));
    float sunStrength = 1.35;

    // Sky Color (lower sky brightness to avoid overexposure on iOS)
    vec3 skyTop = vec3(0.74, 0.86, 1.00);
    vec3 skyBot = vec3(0.92, 0.96, 1.00);
    float h = clamp(p.y * 0.5 + 0.5, 0.0, 1.0);
    vec3 sky = mix(skyBot, skyTop, pow(h, 1.15));

    // Cloud Rendering (Volume integration and scattering)
    vec3 col = sky;
    float T = 1.0;
    vec3 S = vec3(0.0);
    float depthHit = 0.0;

    const int VS = 96;
    float stepLen = 0.040;
    float jitter = hash11(gl_FragCoord.x + gl_FragCoord.y * 17.0) * stepLen;

    vec3 pos = ro + rd * jitter;

    for (int i = 0; i < VS; i++) {
      pos += rd * stepLen;
      if (pos.y < -0.25 || pos.y > 0.85) continue;

      vec3 P = pos + wind;

      float d = cloudField(P);

      if (d > 0.001) {
        if (depthHit == 0.0) depthHit = float(i) * stepLen;
        float sigmaA = 2.15;
        float sigmaS = 3.10;
        float sigmaT = (sigmaA + sigmaS) * d;

        float att = exp(-sigmaT * stepLen);
        float a = 1.0 - att;
        float TrL = lightTransmittance(P, sunDir);
        float cosTheta = dot(rd, sunDir);
        float phase = phaseHG(cosTheta, 0.72);
        vec3 cloudBase = vec3(1.0, 0.995, 0.985);
        vec3 sunCol = vec3(1.08, 1.02, 0.95) * sunStrength;
        vec3 scatter = cloudBase * sunCol * TrL * (0.22 + 0.78 * phase);

        scatter *= mix(1.15, 0.70, smoothstep(0.15, 0.85, d));
        S += T * scatter * a;
        T *= att;

        if (T < 0.02) break;
      }
    }

    col = sky * T + S;

    float fog = exp(-max(depthHit, 0.0) * 0.35);
    col = mix(sky, col, clamp(1.0 - fog * 0.35, 0.0, 1.0));

    col = tonemap(col);
    col = pow(col, vec3(0.95));

    gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
  }`;

  function sh(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  }

  const P = gl.createProgram();
  gl.attachShader(P, sh(gl.VERTEX_SHADER, V));
  gl.attachShader(P, sh(gl.FRAGMENT_SHADER, F));
  gl.linkProgram(P);
  if (!gl.getProgramParameter(P, gl.LINK_STATUS)) throw gl.getProgramInfoLog(P);
  gl.useProgram(P);

  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  1, -1, -1, 1,
    -1, 1,  1, -1,  1, 1
  ]), gl.STATIC_DRAW);
  const loc = gl.getAttribLocation(P, "p");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

  const ur = gl.getUniformLocation(P, "r");
  const ut = gl.getUniformLocation(P, "t");

  function resize() {
    const d = Math.min(2, devicePixelRatio || 1);
    const vw = visualViewport ? visualViewport.width : innerWidth;
    const vh = visualViewport ? visualViewport.height : innerHeight;
    c.width = Math.max(1, Math.floor(vw * d));
    c.height = Math.max(1, Math.floor(vh * d));
    gl.viewport(0, 0, c.width, c.height);
    gl.uniform2f(ur, c.width, c.height);
  }

  addEventListener("resize", resize, { passive: true });
  visualViewport && visualViewport.addEventListener("resize", resize, { passive: true });
  resize();

  let t0 = performance.now(), paused = false;
  document.addEventListener("visibilitychange", () => paused = document.hidden, { passive: true });

  (function loop(now) {
    if (!paused) {
      gl.uniform1f(ut, (now - t0) / 1000);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    requestAnimationFrame(loop);
  })(t0);
})();
</script>
</html>