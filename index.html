<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Quiet Luxe · Composition</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#060606;font:12px ui-monospace,Menlo,Consolas,monospace}
canvas{position:fixed;inset:0;display:block}
#ui{position:fixed;left:12px;right:12px;top:12px;z-index:9;display:flex;gap:10px;align-items:center;pointer-events:none;padding-top:env(safe-area-inset-top)}
#pill{flex:1;min-width:0;padding:10px 12px;border-radius:14px;border:1px solid #ffffff24;
background:linear-gradient(90deg,#ffffff10,#ffd6a814,#7ad7ff10);
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset,0 18px 56px #000b;color:#f7f0e7;mix-blend-mode:screen;
text-shadow:0 0 18px #ffd6a822,0 0 22px #ffffff22;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#pill b{color:#fff}
#btn{pointer-events:auto;padding:10px 14px;border-radius:14px;border:1px solid #fff2;background:#0006;color:#fff;
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset}
#btn:active{transform:translateY(1px)}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99;display:none;
background:#2a0000cc;border:1px solid #ff6a6a55;color:#ffd1d1;border-radius:12px;padding:10px 12px;white-space:pre-wrap}
</style>

<canvas id="c"></canvas>
<div id="ui">
  <div id="pill"><b>QUIET LUXE</b> · <span id="s">building…</span></div>
  <button id="btn">切换</button>
</div>
<div id="err"></div>

<script>
(()=>{"use strict";
const C=document.getElementById("c");
const ctx=C.getContext("2d",{alpha:false});
const S=document.getElementById("s"), BTN=document.getElementById("btn"), ERR=document.getElementById("err");
const mobile=matchMedia("(pointer:coarse)").matches||innerWidth<760;
const clamp=(x,a,b)=>x<a?a:x>b?b:x;
const lerp=(a,b,t)=>a+(b-a)*t;
const mix=(A,B,t)=>[lerp(A[0],B[0],t),lerp(A[1],B[1],t),lerp(A[2],B[2],t)];
const smooth=(a,b,x)=>{x=clamp((x-a)/(b-a),0,1);return x*x*(3-2*x);};
const rgb=(c,a=1)=>`rgba(${c[0]|0},${c[1]|0},${c[2]|0},${a})`;
function showErr(e){ERR.style.display="block";ERR.textContent=String(e&&(e.stack||e.message)||e);}

try{
// -------- size ----------
let W=0,H=0,DPR=1;
function resize(){
  DPR=clamp(devicePixelRatio||1,1,2);
  W=innerWidth; H=innerHeight;
  C.width=Math.max(2,(W*DPR)|0);
  C.height=Math.max(2,(H*DPR)|0);
  C.style.width=W+"px"; C.style.height=H+"px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
  scheduleBuild();
}
addEventListener("resize",resize,{passive:true});

// -------- RNG ----------
function makeRng(seed){let s=seed>>>0;return ()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;}
let seedBase=123456789;
function nextSeed(){seedBase=(seedBase*1664525+1013904223)>>>0;return seedBase;}

// -------- palettes (quiet luxe, warm, no purple) ----------
const PALS=[
  {bg:[252,247,240], a:[235,215,185], b:[196,140,86], ink:[18,15,13]},
  {bg:[250,244,236], a:[232,208,175], b:[180,125,78], ink:[16,14,13]},
  {bg:[248,242,234], a:[226,203,172], b:[170,118,74], ink:[20,16,14]},
  {bg:[251,246,238], a:[235,214,184], b:[200,145,85], ink:[14,13,12]},
];

// -------- offscreen: static composition ----------
let tex=null, tctx=null, texW=0, texH=0;
let grain=null, gctx=null, grainPat=null;
let scene=null, building=false, buildTimer=null;

function makeCanvas(w,h,alpha=false){
  const c=document.createElement("canvas"); c.width=w; c.height=h;
  return [c, c.getContext("2d",{alpha, willReadFrequently:false})];
}

// subtle film grain (no grid, no weave)
function buildGrain(seed){
  const N=256;
  if(!grain){ [grain,gctx]=makeCanvas(N,N,true); }
  grain.width=grain.height=N;
  const im=gctx.createImageData(N,N), d=im.data;
  let s=seed>>>0;
  const rnd=()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;
  for(let i=0;i<d.length;i+=4){
    const r=rnd();
    const v=(r<0.5? r*r : 1-(1-r)*(1-r));
    const n=v-0.5;
    const a=clamp(6 + Math.abs(n)*22, 5, 30);
    d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=a;
  }
  gctx.putImageData(im,0,0);
  grainPat=null;
}

function pickScene(){
  const rnd=makeRng(nextSeed());
  const pal=PALS[(rnd()*PALS.length)|0];

  // composition anchors (intentional, not “平均”)
  const focal = {x: 0.62+0.18*(rnd()-0.5), y: 0.42+0.20*(rnd()-0.5)};
  const weight = rnd()<0.5 ? "left" : "right"; // asymmetry
  const mood = rnd()<0.6 ? "warm" : "neutral";

  // restrained motion: slow “breathing” light, not sweeping
  const lightSpeed = 0.05 + 0.06*rnd();
  const lightAmp   = 0.16 + 0.10*rnd();
  const shadowAmp  = 0.08 + 0.06*rnd();

  // three light nodes (composition-guided)
  const lights=[
    {u:focal.x, v:focal.y, r:0.55, a:0.85},
    {u: weight==="left"?0.28:0.78, v:0.22+0.10*rnd(), r:0.42, a:0.55},
    {u: 0.50+0.10*(rnd()-0.5), v:0.82, r:0.65, a:0.35},
  ];

  return {seed:nextSeed(), pal, focal, weight, mood, lightSpeed, lightAmp, shadowAmp, lights};
}

function blob(x,y,r,col,a,mode="soft-light"){
  tctx.save();
  tctx.globalCompositeOperation=mode;
  const g=tctx.createRadialGradient(x,y,0,x,y,r);
  g.addColorStop(0, rgb(col,a));
  g.addColorStop(0.55, rgb(col,a*0.25));
  g.addColorStop(1, "rgba(0,0,0,0)");
  tctx.fillStyle=g;
  tctx.beginPath();
  tctx.ellipse(x,y,r*1.05,r*0.78,0,0,Math.PI*2);
  tctx.fill();
  tctx.restore();
}

function paintStatic(){
  building=true;
  S.textContent="building…";
  scene=pickScene();
  buildGrain(scene.seed^0x9E3779B9);

  // texture resolution: sharp enough, but stable on iOS
  const scale = clamp(DPR,1, mobile?1.35:1.65);
  texW=Math.max(420,(W*scale)|0);
  texH=Math.max(720,(H*scale)|0);
  [tex,tctx]=makeCanvas(texW,texH,false);

  const rnd=makeRng(scene.seed);
  const {bg,a,b,ink}=scene.pal;

  // 1) background: calm paper-like gradient
  const g=tctx.createLinearGradient(0,0,texW,texH);
  const warmLift = scene.mood==="warm" ? 0.06 : 0.03;
  g.addColorStop(0, rgb(mix(bg,[255,255,255],0.02+warmLift)));
  g.addColorStop(0.52, rgb(mix(a,[255,255,255],0.05)));
  g.addColorStop(1, rgb(mix(b,ink,0.08)));
  tctx.fillStyle=g; tctx.fillRect(0,0,texW,texH);

  // 2) composition mass: big soft forms (intentional placement)
  const fx=scene.focal.x*texW, fy=scene.focal.y*texH;
  const baseR=Math.max(texW,texH)*0.65;

  // main warm body
  blob(fx,fy,baseR*0.62, mix(a,b,0.35), 0.35, "soft-light");
  // counterweight (dark, very subtle, gives “高级”)
  const cx = (scene.weight==="left"?0.18:0.84)*texW;
  const cy = (0.64+0.10*(rnd()-0.5))*texH;
  blob(cx,cy,baseR*0.55, mix(ink,b,0.25), 0.22, "multiply");

  // 3) “author mark”: one or two intentional strokes (not随机噪声)
  tctx.save();
  tctx.globalCompositeOperation="overlay";
  tctx.globalAlpha=0.18;
  tctx.lineCap="round"; tctx.lineJoin="round";
  for(let k=0;k<2;k++){
    const sgn = k?1:-1;
    const x0 = (scene.weight==="left"?0.10:0.78)*texW;
    const y0 = (0.30+0.20*rnd())*texH;
    const x1 = (0.92-0.08*rnd())*texW;
    const y1 = (0.55+0.12*rnd())*texH;
    tctx.strokeStyle = rgb(mix(b,[255,255,255],0.10), 1);
    tctx.lineWidth = 2.2 + 1.2*rnd();
    tctx.beginPath();
    tctx.moveTo(x0,y0);
    tctx.bezierCurveTo(
      lerp(x0,x1,0.35), y0+sgn*(40+90*rnd()),
      lerp(x0,x1,0.70), y1-sgn*(40+90*rnd()),
      x1,y1
    );
    tctx.stroke();
  }
  tctx.restore();

  // 4) micro “surface” (non-grid, non-weave): sparse specks only
  tctx.save();
  tctx.globalCompositeOperation="soft-light";
  for(let i=0;i<320;i++){
    const x=rnd()*texW, y=rnd()*texH;
    const r=0.6+1.6*rnd();
    const col = mix(bg, [255,255,255], 0.35+0.35*rnd());
    tctx.fillStyle=rgb(col, 0.06);
    tctx.beginPath();
    tctx.arc(x,y,r,0,Math.PI*2);
    tctx.fill();
  }
  tctx.restore();

  // 5) vignette: very gentle sculpt (no dirty corners)
  const vg=tctx.createRadialGradient(texW*0.55,texH*0.48,Math.min(texW,texH)*0.22, texW*0.55,texH*0.48, Math.max(texW,texH)*0.78);
  vg.addColorStop(0,"rgba(0,0,0,0)");
  vg.addColorStop(1,`rgba(0,0,0,0.10)`);
  tctx.fillStyle=vg; tctx.fillRect(0,0,texW,texH);

  building=false;
  S.textContent="ready";
}

function scheduleBuild(){
  clearTimeout(buildTimer);
  buildTimer=setTimeout(paintStatic,120);
}

// -------- animation (restrained) ----------
let t=0,last=performance.now(),ema=60;
let auto=setInterval(()=>switchNow(),60*1000);
function switchNow(){ paintStatic(); clearInterval(auto); auto=setInterval(()=>switchNow(),60*1000); }

BTN.addEventListener("click",switchNow);
document.addEventListener("visibilitychange",()=>{
  // iOS: keep stable when returning
  if(!document.hidden) last=performance.now();
},{passive:true});

function drawDynamicLights(time){
  // slow breathing (no sweeping bands)
  const breathe = 0.5+0.5*Math.sin(time*scene.lightSpeed);
  const drift   = 0.5+0.5*Math.sin(time*scene.lightSpeed*0.73 + 1.7);

  // highlight
  ctx.save();
  ctx.globalCompositeOperation="soft-light";
  for(let i=0;i<scene.lights.length;i++){
    const L=scene.lights[i];
    const cx=W*(L.u + (i===0?(drift-0.5)*0.03:(breathe-0.5)*0.02));
    const cy=H*(L.v + (i===0?(breathe-0.5)*0.03:(drift-0.5)*0.02));
    const r=Math.max(W,H)*L.r*(0.92+0.08*breathe);
    const a=scene.lightAmp*L.a*(0.85+0.15*drift);

    const g=ctx.createRadialGradient(cx,cy,0,cx,cy,r);
    g.addColorStop(0,`rgba(255,248,236,${0.16*a})`);
    g.addColorStop(0.35,`rgba(255,230,206,${0.10*a})`);
    g.addColorStop(1,"rgba(255,255,255,0)");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);
  }

  // shadow sculpt (very subtle, gives “贵气”的体积感)
  ctx.globalCompositeOperation="multiply";
  const ang = (time*0.025)%(Math.PI*2);
  const ax=Math.cos(ang), ay=Math.sin(ang);
  const lx=W*(0.5-ax*0.25), ly=H*(0.5-ay*0.20);
  const sg=ctx.createRadialGradient(lx,ly,Math.min(W,H)*0.10, lx,ly, Math.max(W,H)*0.95);
  const sa=scene.shadowAmp*(0.75+0.25*breathe);
  sg.addColorStop(0,"rgba(0,0,0,0)");
  sg.addColorStop(1,`rgba(0,0,0,${0.10*sa})`);
  ctx.fillStyle=sg;
  ctx.fillRect(0,0,W,H);

  ctx.restore();
}

function drawGrain(time){
  if(!grain) return;
  if(!grainPat){
    try{ grainPat=ctx.createPattern(grain,"repeat"); }catch(e){ grainPat=null; }
  }
  if(!grainPat) return;
  // grain is only for banding; keep it extremely light
  ctx.save();
  ctx.globalCompositeOperation="overlay";
  ctx.globalAlpha=0.040*(0.92+0.08*Math.sin(time*2.0));
  const ox=(Math.sin(time*0.9)*3)|0, oy=(Math.cos(time*1.1)*3)|0;
  ctx.translate(ox,oy);
  ctx.fillStyle=grainPat;
  ctx.fillRect(-10,-10,W+20,H+20);
  ctx.restore();
}

function frame(now){
  requestAnimationFrame(frame);
  const dt=now-last; last=now;
  const fps=1000/(dt||16.7); ema=ema*0.92+fps*0.08;
  t += dt*0.001;

  if(!tex || building) return;

  ctx.save();
  ctx.imageSmoothingEnabled=true;
  ctx.clearRect(0,0,W,H);

  // draw static composition (micro drift, almost imperceptible)
  const dx = Math.sin(t*0.03)*6;
  const dy = Math.cos(t*0.025)*6;
  ctx.drawImage(tex, dx, dy, W, H);

  // dynamic light (restrained)
  drawDynamicLights(t);

  // grain
  drawGrain(t);

  ctx.restore();

  if(((now/600)|0)%2===0){
    S.textContent = `fps~${ema.toFixed(0)} · composition · restrained light`;
  }
}

// init
resize();
paintStatic();
requestAnimationFrame(frame);

}catch(e){showErr(e);}
})();
</script>