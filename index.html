<!doctype html>
<html lang="zh">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Blue Sky & White Volumetric Clouds (No Textures)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#cfe8ff}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}
  #err{
    position:fixed;left:12px;top:12px;right:12px;max-height:50vh;overflow:auto;
    padding:10px 12px;border-radius:10px;background:rgba(0,0,0,.78);color:#fff;
    font:12px/1.35 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;display:none;z-index:9;
    white-space:pre-wrap;word-break:break-word;
  }
</style>
<canvas id="c"></canvas>
<div id="err"></div>

<script>
(()=> {
  const c = document.getElementById("c");
  const err = document.getElementById("err");
  const showErr = (e)=>{
    err.style.display="block";
    err.textContent = String(e && e.message ? e.message : e);
    console.error(e);
  };

  const gl = c.getContext("webgl",{
    antialias:false, alpha:false, premultipliedAlpha:false, depth:false, stencil:false
  });
  if(!gl){
    const g=c.getContext("2d"); if(!g) return;
    g.fillStyle="#000"; g.font="16px system-ui";
    g.fillText("WebGL not supported",20,30);
    return;
  }

  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      throw new Error(gl.getShaderInfoLog(s) || "Shader compile failed");
    }
    return s;
  }
  function link(vs, fs){
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(p) || "Program link failed");
    }
    return p;
  }
  function tex2D(w,h,filter){
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    return t;
  }
  function fboForTexture(tex){
    const f = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE){
      throw new Error("Framebuffer incomplete");
    }
    return f;
  }

  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]), gl.STATIC_DRAW);

  const VS = `
    attribute vec2 p;
    varying vec2 v;
    void main(){ v = p*0.5 + 0.5; gl_Position = vec4(p,0.0,1.0); }
  `;

  // Pass 1: cheap cloud mask (aim: sparse cumulus, lots of blue gaps)
  const FS_MASK = `
    precision mediump float;
    uniform vec2 r;
    uniform float t;
    varying vec2 v;

    float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
    float noise(vec2 p){
      vec2 i=floor(p), f=fract(p); f=f*f*(3.0-2.0*f);
      float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
      return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
    }
    float fbm2(vec2 p){
      float v=0.0,a=0.62;
      for(int i=0;i<3;i++){
        v += a*noise(p);
        p = p*1.95 + 17.3;
        a *= 0.53;
      }
      return v;
    }

    void main(){
      vec2 p = v*2.0 - 1.0;
      p.x *= r.x / r.y;

      float tt = t*0.02; // slower -> calmer sky
      vec2 drift = vec2(tt*0.75, tt*0.40);

      // bigger shapes, fewer small noisy patches
      vec2 q = p*0.78;
      float d = fbm2(q + drift);

      // cloud band: keep clouds mostly upper-mid, leave lots of blue at bottom
      float h = clamp((p.y + 0.20)*0.85, 0.0, 1.0);
      float band = smoothstep(0.10, 0.35, h) * (1.0 - smoothstep(0.85, 1.00, h));
      d *= band;

      // enforce sparse coverage (more gaps): push threshold up
      float m = smoothstep(0.58, 0.82, d);

      // slightly soften / dilate so thin edges aren't lost
      m = pow(m, 0.70);

      gl_FragColor = vec4(m,m,m,1.0);
    }
  `;

  // Pass 2: low-res volumetric clouds + checkerboard + temporal accumulation
  // Here we intentionally bias to "white" by:
  // - lower absorption
  // - stronger ambient fill
  // - shadow never goes too dark
  // - warm sun + cool sky
  const FS_CLOUD = `
    precision highp float;
    uniform vec2 r;
    uniform float t;
    uniform sampler2D prevTex;
    uniform sampler2D maskTex;
    uniform float parity;
    varying vec2 v;

    float sat(float x){ return clamp(x,0.0,1.0); }
    vec3  sat3(vec3 x){ return clamp(x,0.0,1.0); }

    float hash12(vec2 p){
      vec3 p3 = fract(vec3(p.xyx)*0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y)*p3.z);
    }
    float hash31(vec3 p){
      p = fract(p*0.1031);
      p += dot(p, p.yzx + 33.33);
      return fract((p.x+p.y)*p.z);
    }
    float noise3(vec3 p){
      vec3 i=floor(p), f=fract(p);
      f=f*f*(3.0-2.0*f);
      float n000=hash31(i+vec3(0,0,0));
      float n100=hash31(i+vec3(1,0,0));
      float n010=hash31(i+vec3(0,1,0));
      float n110=hash31(i+vec3(1,1,0));
      float n001=hash31(i+vec3(0,0,1));
      float n101=hash31(i+vec3(1,0,1));
      float n011=hash31(i+vec3(0,1,1));
      float n111=hash31(i+vec3(1,1,1));
      float nx00=mix(n000,n100,f.x);
      float nx10=mix(n010,n110,f.x);
      float nx01=mix(n001,n101,f.x);
      float nx11=mix(n011,n111,f.x);
      float nxy0=mix(nx00,nx10,f.y);
      float nxy1=mix(nx01,nx11,f.y);
      return mix(nxy0,nxy1,f.z);
    }
    float fbm3(vec3 p){
      float v=0.0,a=0.56;
      for(int i=0;i<5;i++){
        v += a*noise3(p);
        p = p*1.92 + vec3(19.7,7.3,13.1);
        a *= 0.52;
      }
      return v;
    }
    float ridged(vec3 p){
      float n = fbm3(p);
      n = 1.0 - abs(2.0*n - 1.0);
      return n*n;
    }

    // phase: keep forward scattering but not too peaky
    float phaseHG(float cosTheta, float g){
      float gg=g*g;
      float d=1.0+gg-2.0*g*cosTheta;
      return (1.0-gg) / (4.0*3.14159265*pow(d,1.5));
    }

    // cumulus-friendly height profile: thicker mid, softer top
    float heightProfile(float h){
      float base = smoothstep(0.05, 0.22, h);
      float mid  = smoothstep(0.18, 0.55, h);
      float top  = 1.0 - smoothstep(0.70, 0.98, h);
      return base * mix(0.65, 1.0, mid) * top;
    }

    // density: more "puffy" and less sheet-like
    float cloudDensity(vec3 P){
      vec3 p = P;
      float tt = t*0.05;

      // gentler warp (avoid stormy turbulence)
      vec3 w;
      w.x = fbm3(p*0.50 + vec3(0.0, 0.0, tt));
      w.y = fbm3(p*0.50 + vec3(9.1, 3.7, tt*0.8));
      w.z = fbm3(p*0.50 + vec3(2.8, 7.9, tt*0.7));
      p += (w - 0.5) * 0.65;

      // shape + detail (detail reduced to keep it fluffy/bright)
      float d0 = fbm3(p*0.80 + vec3(t*0.015, t*0.010, 0.0));
      float d1 = fbm3(p*1.60 - vec3(t*0.018, 0.0, t*0.012));
      float dens = d0*0.86 + d1*0.14;

      float h = sat((P.y - 0.18) / 0.92);
      dens *= heightProfile(h);

      // erosion: only nibble edges, not carve dark noisy holes
      float er = ridged(p*2.9 + vec3(0.0, t*0.06, 0.0));
      float et = mix(0.06, 0.22, smoothstep(0.55, 0.98, h));
      dens -= er * et;

      // make coverage sparse and keep interiors solid-white
      dens = smoothstep(0.55, 0.86, dens);
      dens = pow(dens, 1.10);

      return sat(dens);
    }

    // shadow: clamp darkness heavily (white cloud shadows are soft)
    float shadowToSun(vec3 P, vec3 L, float localD){
      if(localD < 0.14) return 1.0;
      float s=1.0, dist=0.0;
      for(int i=0;i<4;i++){
        dist += 0.20 + 0.07*float(i);
        float d = cloudDensity(P + L*dist);
        s *= exp(-d * 1.10); // softer shadow attenuation
        if(s < 0.35) break;  // never go too dark
      }
      return clamp(s, 0.45, 1.0);
    }

    void main(){
      vec2 frag = gl_FragCoord.xy;
      float cb = mod(frag.x + frag.y, 2.0);
      vec4 prev = texture2D(prevTex, v);

      if(abs(cb - parity) > 0.1){
        gl_FragColor = prev;
        return;
      }

      float m = texture2D(maskTex, v).r;
      if(m < 0.04){
        vec4 clear = vec4(0.0,0.0,0.0,1.0);
        gl_FragColor = mix(prev, clear, 0.22);
        return;
      }

      vec2 uv = v*2.0 - 1.0;
      uv.x *= r.x / r.y;

      // Camera aimed slightly upward to emphasize sky
      vec3 ro = vec3(0.0, 0.48, 2.15);
      vec3 rd = normalize(vec3(uv.x, uv.y*0.82 + 0.06, -1.30));

      // higher sun like noon; gives bright top and nice rim
      vec3 sunDir = normalize(vec3(0.35, 0.78, -0.20));

      // slab: clouds higher, keep bottom blue
      float yMin=0.22, yMax=1.12;
      float invY = 1.0 / max(abs(rd.y), 1e-4);
      float s1 = (yMin - ro.y) * invY * sign(rd.y);
      float s2 = (yMax - ro.y) * invY * sign(rd.y);
      float sNear = min(s1,s2);
      float sFar  = max(s1,s2);
      float sStart = max(sNear, 0.0);
      float sEnd   = max(sFar,  0.0);

      if(sEnd <= sStart){
        vec4 clear = vec4(0.0,0.0,0.0,1.0);
        gl_FragColor = mix(prev, clear, 0.24);
        return;
      }

      // stochastic jitter for temporal sampling
      float j = hash12(frag + t*53.0) - 0.5;

      vec3 col = vec3(0.0);
      float T = 1.0;
      float s = sStart;

      float horizon = pow(1.0 - sat(abs(rd.y)), 1.20);
      float baseStep = mix(0.24, 0.16, horizon);

      // White cloud: weaker absorption, higher albedo-like scattering
      float absorption = 0.78;
      float scatterStrength = 1.35;

      // phase tuned for pleasant forward scatter
      float g = 0.55;

      // coarse empty-space skip
      for(int i=0;i<10;i++){
        if(s > sEnd || T < 0.03) break;

        vec3 P = ro + rd*(s + j*0.05);

        // coarse density prediction
        float coarse = fbm3(P*0.42 + vec3(t*0.01,0.0,t*0.01));
        float hh = sat((P.y - yMin) / (yMax - yMin));
        coarse *= heightProfile(hh);

        if(coarse < 0.07){
          s += baseStep * 2.4;
          continue;
        }

        float d = cloudDensity(P);

        // adaptive step
        float stepLen = baseStep * mix(1.55, 0.80, d);

        // lighting
        float cosTheta = dot(rd, sunDir) * -1.0;
        float phase = phaseHG(cosTheta, g);

        float sh = shadowToSun(P, sunDir, d);

        // Strong sky fill (keeps shadows bright)
        vec3 skyFillTop = vec3(0.72, 0.86, 1.00);
        vec3 skyFillLow = vec3(0.94, 0.97, 1.00);
        vec3 ambient = mix(skyFillLow, skyFillTop, hh);

        // Sun is warm but not yellow
        vec3 sunCol = vec3(1.00, 0.99, 0.96);

        // Multi-scatter-ish cheat:
        //  - keep a big ambient base
        //  - add sun scattering but clamp contrast
        vec3 light = ambient * 1.25
                   + sunCol * (0.85*sh) * phase * 6.2;

        float att = exp(-d * absorption * stepLen);

        // scattering accum: keep it white (albedo-like)
        vec3 scatter = d * scatterStrength * light;

        col += T * (1.0 - att) * scatter;
        T *= att;

        s += stepLen;
      }

      // physical rim from transmittance, keep it subtle & white
      float edge = pow(1.0 - T, 0.70);
      col += vec3(1.0) * (0.05 + 0.14*edge) * edge;

      // tonemap to LDR for RGBA8
      // (brighter mapping for sunny scene)
      vec3 ldr = col / (1.0 + col*0.45);
      ldr = pow(sat3(ldr), vec3(0.98));

      vec4 curr = vec4(ldr, sat(T));

      // Temporal accumulation: be responsive where clouds exist
      float dA = abs(curr.a - prev.a);
      float a = 0.10;
      a = mix(a, 0.22, m);
      a = (dA > 0.12) ? 1.0 : a;

      gl_FragColor = mix(prev, curr, a);
    }
  `;

  // Pass 3: final composite with lively blue sky + sun glow + edge-aware upsample
  const FS_FINAL = `
    precision highp float;
    uniform vec2 r;
    uniform float t;
    uniform sampler2D cloudTex;
    uniform sampler2D maskTex;
    uniform vec2 lr;
    varying vec2 v;

    float sat(float x){ return clamp(x,0.0,1.0); }
    vec3  sat3(vec3 x){ return clamp(x,0.0,1.0); }

    vec4 sampleEA(vec2 uv){
      vec2 texel = 1.0 / lr;
      vec2 p = uv * lr - 0.5;
      vec2 i = floor(p);
      vec2 f = fract(p);

      vec2 uv00 = (i + vec2(0.0,0.0) + 0.5) * texel;
      vec2 uv10 = (i + vec2(1.0,0.0) + 0.5) * texel;
      vec2 uv01 = (i + vec2(0.0,1.0) + 0.5) * texel;
      vec2 uv11 = (i + vec2(1.0,1.0) + 0.5) * texel;

      float m00 = texture2D(maskTex, uv00).r;
      float m10 = texture2D(maskTex, uv10).r;
      float m01 = texture2D(maskTex, uv01).r;
      float m11 = texture2D(maskTex, uv11).r;
      float mc  = texture2D(maskTex, (i+0.5)*texel).r;

      float k = 12.0;
      float w00 = exp(-abs(m00-mc)*k);
      float w10 = exp(-abs(m10-mc)*k);
      float w01 = exp(-abs(m01-mc)*k);
      float w11 = exp(-abs(m11-mc)*k);

      float b00 = (1.0-f.x)*(1.0-f.y);
      float b10 = (f.x)*(1.0-f.y);
      float b01 = (1.0-f.x)*(f.y);
      float b11 = (f.x)*(f.y);

      w00*=b00; w10*=b10; w01*=b01; w11*=b11;
      float ws = max(w00+w10+w01+w11, 1e-4);

      vec4 c00 = texture2D(cloudTex, uv00);
      vec4 c10 = texture2D(cloudTex, uv10);
      vec4 c01 = texture2D(cloudTex, uv01);
      vec4 c11 = texture2D(cloudTex, uv11);

      return (c00*w00 + c10*w10 + c01*w01 + c11*w11) / ws;
    }

    void main(){
      vec2 p = v*2.0 - 1.0;
      p.x *= r.x / r.y;

      // lively blue sky gradient
      vec3 zenith = vec3(0.20, 0.55, 0.98);
      vec3 mid    = vec3(0.45, 0.74, 1.00);
      vec3 horizon= vec3(0.82, 0.92, 1.00);

      float y = sat(p.y*0.55 + 0.55);
      vec3 sky = mix(horizon, mid, smoothstep(0.00, 0.65, y));
      sky = mix(sky, zenith, smoothstep(0.55, 1.00, y));

      // subtle sun glow in sky (screen-space approx)
      // keep it gentle so it doesn't wash clouds
      vec2 sunPos = vec2(0.25, 0.55);
      vec2 sp = vec2(p.x, p.y);
      float sd = length(sp - sunPos);
      float glow = exp(-sd*6.0) * 0.18 + exp(-sd*16.0)*0.08;
      sky += vec3(1.0, 0.98, 0.92) * glow;

      vec4 cloud = sampleEA(v);

      // cloudTex stores: RGB (cloud add light), A (T)
      vec3 col = sky * cloud.a + cloud.rgb;

      // final mild curve
      col = col / (1.0 + col*0.15);
      col = pow(sat3(col), vec3(0.995));
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  let progMask, progCloud, progFinal;
  try{
    progMask  = link(VS, FS_MASK);
    progCloud = link(VS, FS_CLOUD);
    progFinal = link(VS, FS_FINAL);
  }catch(e){
    showErr(e);
    return;
  }

  function bindQuad(prog){
    gl.useProgram(prog);
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    const loc = gl.getAttribLocation(prog, "p");
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);
  }

  const U = {
    mask: {
      r: gl.getUniformLocation(progMask, "r"),
      t: gl.getUniformLocation(progMask, "t"),
    },
    cloud: {
      r: gl.getUniformLocation(progCloud, "r"),
      t: gl.getUniformLocation(progCloud, "t"),
      prevTex: gl.getUniformLocation(progCloud, "prevTex"),
      maskTex: gl.getUniformLocation(progCloud, "maskTex"),
      parity: gl.getUniformLocation(progCloud, "parity"),
    },
    final: {
      r: gl.getUniformLocation(progFinal, "r"),
      t: gl.getUniformLocation(progFinal, "t"),
      cloudTex: gl.getUniformLocation(progFinal, "cloudTex"),
      maskTex: gl.getUniformLocation(progFinal, "maskTex"),
      lr: gl.getUniformLocation(progFinal, "lr"),
    }
  };

  // Architecture: fixed low-res cloud pipeline
  const CLOUD_SCALE = 0.62;

  let W=1,H=1,LW=1,LH=1;
  let cloudTexA=null, cloudTexB=null, cloudFboA=null, cloudFboB=null;
  let maskTex=null, maskFbo=null;

  function allocTargets(){
    function del(t,f){ if(t) gl.deleteTexture(t); if(f) gl.deleteFramebuffer(f); }
    del(cloudTexA, cloudFboA);
    del(cloudTexB, cloudFboB);
    del(maskTex, maskFbo);

    cloudTexA = tex2D(LW,LH,gl.LINEAR);
    cloudTexB = tex2D(LW,LH,gl.LINEAR);
    maskTex   = tex2D(LW,LH,gl.LINEAR);

    cloudFboA = fboForTexture(cloudTexA);
    cloudFboB = fboForTexture(cloudTexB);
    maskFbo   = fboForTexture(maskTex);

    gl.viewport(0,0,LW,LH);

    gl.bindFramebuffer(gl.FRAMEBUFFER, cloudFboA);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.bindFramebuffer(gl.FRAMEBUFFER, cloudFboB);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  function resize(){
    const dpr = Math.min(2, (devicePixelRatio||1));
    const vw = (visualViewport ? visualViewport.width  : innerWidth);
    const vh = (visualViewport ? visualViewport.height : innerHeight);

    W = Math.max(1, Math.floor(vw * dpr));
    H = Math.max(1, Math.floor(vh * dpr));
    c.width = W; c.height = H;

    LW = Math.max(2, Math.floor(W * CLOUD_SCALE));
    LH = Math.max(2, Math.floor(H * CLOUD_SCALE));
    allocTargets();
  }
  addEventListener("resize", resize, {passive:true});
  if(visualViewport) visualViewport.addEventListener("resize", resize, {passive:true});
  resize();

  let t0 = performance.now();
  let paused=false;
  document.addEventListener("visibilitychange", ()=>paused=document.hidden, {passive:true});

  let ping=0, frame=0;

  function setTex(unit, tex, loc){
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.uniform1i(loc, unit);
  }

  (function loop(now){
    if(!paused){
      const time = (now - t0) * 0.001;
      const writeFbo = ping ? cloudFboB : cloudFboA;
      const readTex  = ping ? cloudTexA : cloudTexB;

      // Pass 1: mask
      gl.bindFramebuffer(gl.FRAMEBUFFER, maskFbo);
      gl.viewport(0,0,LW,LH);
      bindQuad(progMask);
      gl.uniform2f(U.mask.r, LW, LH);
      gl.uniform1f(U.mask.t, time);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Pass 2: cloud integrate + temporal accumulate
      gl.bindFramebuffer(gl.FRAMEBUFFER, writeFbo);
      gl.viewport(0,0,LW,LH);
      bindQuad(progCloud);
      gl.uniform2f(U.cloud.r, LW, LH);
      gl.uniform1f(U.cloud.t, time);
      gl.uniform1f(U.cloud.parity, (frame & 1) ? 1.0 : 0.0);
      setTex(0, readTex, U.cloud.prevTex);
      setTex(1, maskTex, U.cloud.maskTex);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      ping ^= 1;
      const cloudTex = ping ? cloudTexB : cloudTexA;

      // Pass 3: final
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0,0,W,H);
      bindQuad(progFinal);
      gl.uniform2f(U.final.r, W, H);
      gl.uniform1f(U.final.t, time);
      gl.uniform2f(U.final.lr, LW, LH);
      setTex(0, cloudTex, U.final.cloudTex);
      setTex(1, maskTex, U.final.maskTex);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      frame++;
    }
    requestAnimationFrame(loop);
  })(t0);

})();
</script>
</html>