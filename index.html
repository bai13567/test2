<!doctype html><html lang="zh"><meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Cool Realtime Background</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}
  .hint{position:fixed;left:14px;bottom:12px;color:#fff8;font:12px/1.2 system-ui;user-select:none}
</style>
<canvas id="c"></canvas><div class="hint">tap = change mood</div>
<script>
(()=>{const c=document.getElementById("c"),gl=c.getContext("webgl",{antialias:false,alpha:false});
if(!gl){const g=c.getContext("2d");g.fillStyle="#fff";g.font="16px system-ui";g.fillText("WebGL not supported",20,30);return;}
const V=`attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}`;
const F=`precision highp float;
uniform vec2 r;uniform float t;uniform int mood;
#define TAU 6.28318530718
float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);}
float n2(vec2 p){vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
  float a=hash(i),b=hash(i+vec2(1,0)),c=hash(i+vec2(0,1)),d=hash(i+vec2(1,1));
  return mix(mix(a,b,f.x),mix(c,d,f.x),f.y);
}
float fbm(vec2 p){
  float v=0.,a=.55;mat2 M=mat2(1.6,1.2,-1.2,1.6);
  for(int i=0;i<5;i++){v+=a*n2(p);p=M*p+0.07*t;a*=.55;}
  return v;
}
vec3 pal(float x){
  if(mood==0) return .55+.45*cos(TAU*(vec3(0.10,0.35,0.65)+x));
  if(mood==1) return .55+.45*cos(TAU*(vec3(0.00,0.15,0.35)+x*1.1));
  if(mood==2) return .55+.45*cos(TAU*(vec3(0.55,0.25,0.05)+x*0.9));
  return .55+.45*cos(TAU*(vec3(0.20,0.55,0.85)+x*1.2));
}
void main(){
  vec2 uv=(gl_FragCoord.xy-.5*r)/min(r.x,r.y);
  vec2 p=uv;
  float f=fbm(p*2.2 + vec2(0.0,0.18*t));
  float g=fbm(p*5.2 - vec2(0.12*t,0.0));
  float flow = f*0.75 + g*0.35;
  float ring = smoothstep(0.58,0.02,abs(sin((flow+t*0.22)*3.0)));
  float glow = pow(max(0.0,1.0-0.88*length(uv)),2.0);
  vec3 col = pal(flow + 0.07*sin(t+uv.x*1.8));
  col *= 0.62 + 0.9*ring;
  col += 0.85*glow*pal(flow+0.18);
  col = pow(col, vec3(0.92));
  gl_FragColor=vec4(col,1.0);
}`;
function sh(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);return s;}
const prog=gl.createProgram();gl.attachShader(prog,sh(gl.VERTEX_SHADER,V));gl.attachShader(prog,sh(gl.FRAGMENT_SHADER,F));
gl.linkProgram(prog);if(!gl.getProgramParameter(prog,gl.LINK_STATUS))throw gl.getProgramInfoLog(prog);
gl.useProgram(prog);
const buf=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]),gl.STATIC_DRAW);
const loc=gl.getAttribLocation(prog,"p");gl.enableVertexAttribArray(loc);gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);
const ur=gl.getUniformLocation(prog,"r"),ut=gl.getUniformLocation(prog,"t"),uMood=gl.getUniformLocation(prog,"mood");
let mood=0,dp=1,paused=false;

// iOS/Safari 适配：用 visualViewport + 限制 DPR + 处理后台暂停
function resize(){
  const vw=visualViewport?visualViewport.width:innerWidth;
  const vh=visualViewport?visualViewport.height:innerHeight;
  dp=Math.min(2,devicePixelRatio||1);
  c.width=Math.max(1,Math.floor(vw*dp));
  c.height=Math.max(1,Math.floor(vh*dp));
  gl.viewport(0,0,c.width,c.height);
  gl.uniform2f(ur,c.width,c.height);
}
addEventListener("resize",resize,{passive:true});
visualViewport && visualViewport.addEventListener("resize",resize,{passive:true});
resize();

function setPaused(x){paused=x;}
document.addEventListener("visibilitychange",()=>setPaused(document.hidden),{passive:true});

gl.uniform1i(uMood,mood);
function tap(){mood=(mood+1)%4;gl.uniform1i(uMood,mood);}
addEventListener("touchstart",e=>{e.preventDefault();tap();},{passive:false});
addEventListener("click",tap,{passive:true});

let t0=performance.now();
(function loop(now){
  if(!paused){
    const tt=(now-t0)/1000;
    gl.uniform1f(ut,tt);
    gl.drawArrays(gl.TRIANGLES,0,6);
  }
  requestAnimationFrame(loop);
})(t0);
})();
</script>
</html>