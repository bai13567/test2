<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Warm Healing — Evolving Field</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#0b0605;font:12px ui-monospace,Menlo,Consolas,monospace}
canvas{position:fixed;inset:0;display:block}
#ui{position:fixed;left:12px;right:12px;top:12px;z-index:9;display:flex;gap:10px;align-items:center;pointer-events:none;padding-top:env(safe-area-inset-top)}
#pill{flex:1;min-width:0;padding:10px 12px;border-radius:14px;border:1px solid #ffd3a855;
background:linear-gradient(90deg,#ffbf6a22,#ffd6a822,#7ad7ff12);
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset,0 16px 44px #000c;color:#ffe9d6;mix-blend-mode:screen;
text-shadow:0 0 18px #ffbf6a55,0 0 30px #ff7aa822;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#pill b{color:#fff}
#btn{pointer-events:auto;padding:10px 14px;border-radius:14px;border:1px solid #fff2;background:#0006;color:#fff;
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset}
#btn:active{transform:translateY(1px)}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99;display:none;
background:#2a0000cc;border:1px solid #ff6a6a55;color:#ffd1d1;border-radius:12px;padding:10px 12px;white-space:pre-wrap}
</style>

<canvas id="c"></canvas>
<canvas id="g"></canvas>

<div id="ui">
  <div id="pill"><b>WARM HEALING</b> · <span id="s">loading…</span></div>
  <button id="btn">切换</button>
</div>
<div id="err"></div>

<script>
(()=>{"use strict";
const C=document.getElementById("c"), G=document.getElementById("g");
const ctx=C.getContext("2d",{alpha:false}), gtx=G.getContext("2d",{alpha:true});
const S=document.getElementById("s"), BTN=document.getElementById("btn"), ERR=document.getElementById("err");
const mobile=matchMedia("(pointer:coarse)").matches||innerWidth<760;
const clamp=(x,a,b)=>x<a?a:x>b?b:x, lerp=(a,b,t)=>a+(b-a)*t;

function showErr(e){ERR.style.display="block";ERR.textContent=String(e&&(e.stack||e.message)||e);}

try{
// ---------- size / DPR ----------
let W=0,H=0,DPR=1;
function resize(){
  DPR=clamp(devicePixelRatio||1,1,2);
  W=innerWidth; H=innerHeight;
  for(const c of [C,G]){
    c.width=Math.max(2,Math.floor(W*DPR));
    c.height=Math.max(2,Math.floor(H*DPR));
    c.style.width=W+"px"; c.style.height=H+"px";
  }
  ctx.setTransform(DPR,0,0,DPR,0,0);
  gtx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener("resize",resize,{passive:true}); resize();

// ---------- RNG ----------
function makeRng(seed){let s=seed>>>0;return ()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;}

// ---------- color helpers ----------
function hex2rgb(h){h=h.replace("#","");const n=parseInt(h,16);return[(n>>16)&255,(n>>8)&255,n&255];}
function mix3(a,b,t){return [lerp(a[0],b[0],t),lerp(a[1],b[1],t),lerp(a[2],b[2],t)];}
function rgb2hsv(r,g,b){
  r/=255;g/=255;b/=255;
  const mx=Math.max(r,g,b), mn=Math.min(r,g,b), d=mx-mn;
  let h=0;
  if(d){ if(mx===r) h=((g-b)/d)%6; else if(mx===g) h=(b-r)/d+2; else h=(r-g)/d+4; h/=6; if(h<0) h+=1; }
  const s=mx? d/mx:0, v=mx;
  return [h,s,v];
}

// ---------- palettes (warm healing, avoid purple/magenta) ----------
const PALS=[
  ["#FFF7F0","#FFE5C9","#E8B07C","#FFF9F4"],
  ["#FFF5EC","#FFDDB8","#E6A77A","#FFF9F3"],
  ["#FFF3E6","#FFD6A8","#E2A06D","#FFF8F1"],
  ["#FFF6EE","#FFE2C2","#E5A877","#FFF9F4"],
  ["#FFF4EA","#FFDAB3","#E6A27A","#FFF8F2"]
].map(p=>p.map(hex2rgb));

// ---------- fast value noise (2D) ----------
function hash2(ix,iy,seed){
  let x=(ix*374761393+iy*668265263)^(seed*1442695041);
  x=(x^(x>>>13))*1274126177;
  return ((x^(x>>>16))>>>0)/4294967295;
}
function vnoise2(x,y,seed){
  const ix=x|0, iy=y|0;
  const fx=x-ix, fy=y-iy;
  const a=hash2(ix,iy,seed), b=hash2(ix+1,iy,seed), c=hash2(ix,iy+1,seed), d=hash2(ix+1,iy+1,seed);
  const ux=fx*fx*(3-2*fx), uy=fy*fy*(3-2*fy);
  const ab=a+(b-a)*ux, cd=c+(d-c)*ux;
  return ab+(cd-ab)*uy;
}
function fbm(x,y,seed){
  // 3 octaves for speed; looks natural once domain-warped
  let f=0, amp=0.55, freq=1;
  f += amp*vnoise2(x*freq,y*freq,seed); freq*=2; amp*=0.5;
  f += amp*vnoise2(x*freq,y*freq,seed+101); freq*=2; amp*=0.5;
  f += amp*vnoise2(x*freq,y*freq,seed+202);
  return f;
}

// ---------- low-res field renderer (architecture: evolving density field) ----------
const off=document.createElement("canvas");
const octx=off.getContext("2d",{alpha:false, willReadFrequently:true});
let OW=0,OH=0, img=null, data=null;

// adaptive resolution (keeps iOS smooth)
let q= mobile ? 0.38 : 0.42; // quality factor
function allocOff(){
  // clamp to keep cost stable
  OW=Math.max(160, Math.min(480, (W*q)|0));
  OH=Math.max(260, Math.min(840, (H*q)|0));
  off.width=OW; off.height=OH;
  img=octx.createImageData(OW,OH);
  data=img.data;
}
allocOff();

function smoothstep(a,b,x){x=clamp((x-a)/(b-a),0,1);return x*x*(3-2*x);}

// ---------- “scene” parameters + scoring (avoid ugly / avoid sameness) ----------
let seedBase=123456789;
const HISTORY=[], HIST_MAX=8;
function sim(a,b){
  let dot=0,na=0,nb=0;
  for(let i=0;i<a.length;i++){dot+=a[i]*b[i];na+=a[i]*a[i];nb+=b[i]*b[i];}
  return dot/Math.sqrt((na*nb)+1e-9);
}

function makeScene(seed){
  const rnd=makeRng(seed);
  const pal=PALS[(rnd()*PALS.length)|0];
  // key: domain warp (flow) + time into noise (evolution), not translation
  const warp=0.35+0.65*rnd();      // warp strength
  const flow=0.06+0.12*rnd();      // flow speed (slow)
  const scale=1.15+1.85*rnd();     // feature size
  const detail=0.70+0.55*rnd();    // cloud contrast
  const softness=0.55+0.35*rnd();  // cloud edge softness
  const glow=0.12+0.20*rnd();      // warm lift in highlights
  const vign=0.06+0.12*rnd();
  const grain=0.05+0.03*rnd();
  // feature vector for diversity
  const feat=[warp,flow,scale,detail,softness,glow,vign,grain,(pal[1][0]/255)];
  return {seed,pal,warp,flow,scale,detail,softness,glow,vign,grain,feat,score:0};
}

// quick preview scoring on small sample points (fast, no extra canvas)
function scoreScene(sc){
  // compute a few probes in normalized space at a few times; score warmth, avoid purple, avoid muddy/dark
  const probes=[[0.2,0.2],[0.5,0.35],[0.75,0.55],[0.35,0.8],[0.8,0.85]];
  const times=[0.9,2.4,3.9];
  let total=0;
  for(const tt of times){
    let warm=0,pur=0,dark=0,lum=0,sat=0;
    for(const p of probes){
      const x=p[0], y=p[1];
      // emulate same field math used in render (coarse)
      const X=x*sc.scale*2.2, Y=y*sc.scale*2.2;
      const t=tt*sc.flow;

      // flow field (vector) from low freq noise; time enters noise => evolving
      const fx = fbm(X*0.55 + 12.3, Y*0.55 + 4.7, sc.seed+11);
      const fy = fbm(X*0.55 + 8.1 + t*1.2, Y*0.55 + 15.9, sc.seed+23);
      const ang = 6.28318*fx;
      const wx = Math.cos(ang)*sc.warp*0.55 + (fy-0.5)*sc.warp*0.6;
      const wy = Math.sin(ang)*sc.warp*0.55 + (fx-0.5)*sc.warp*0.6;

      // density field with domain warp; time enters noise as offset
      const d = fbm(X+wx + t*0.7, Y+wy + t*0.9, sc.seed+101);
      const m = smoothstep(0.42, 0.78, d);                 // cloud mass
      const edge = Math.pow(m, 1.2+0.9*sc.softness);        // soften
      // base gradient
      const top=sc.pal[0], mid=sc.pal[1], low=sc.pal[2], glow=sc.pal[3];
      const gy=clamp(y,0,1);
      let base = gy<0.65 ? mix3(top,mid,gy/0.65) : mix3(mid,low,(gy-0.65)/0.35);

      // cloud lighting: lift towards warm glow, avoid harsh whites
      const lift = edge*sc.detail;
      base = mix3(base, glow, lift*sc.glow);
      // mild highlight
      base = mix3(base, [255,255,255], lift*0.06);

      const r=base[0]|0,g=base[1]|0,b=base[2]|0;
      const [hh,ss,vv]=rgb2hsv(r,g,b);
      lum += vv; sat += ss;
      if((hh>=0 && hh<=70/360) || (hh>=0.98)) warm++;
      if(hh>=255/360 && hh<=330/360) pur++;
      if(vv<0.14) dark++;
    }
    const n=probes.length;
    const warmP=warm/n, purP=pur/n, darkP=dark/n, lumM=lum/n, satM=sat/n;
    // score: bright warm + moderate sat; punish purple/dark
    let s = 100*(0.45*clamp((warmP-0.6)/0.4,0,1) + 0.40*Math.exp(-Math.pow((lumM-0.62)/0.18,2)) + 0.15*Math.exp(-Math.pow((satM-0.42)/0.20,2)))
            - 100*(0.65*clamp((purP-0.02)/0.08,0,1) + 0.35*clamp((darkP-0.10)/0.25,0,1));
    total += clamp(s,0,100);
  }
  let score=total/times.length;

  // diversity penalty if too similar to recent
  if(HISTORY.length){
    let mx=0; for(const f of HISTORY) mx=Math.max(mx, sim(sc.feat,f));
    score -= 18*clamp((mx-0.92)/0.08,0,1);
  }
  sc.score=clamp(score,0,100);
  return sc.score;
}

function pickScene(){
  let best=null, bestS=-1;
  for(let i=0;i<18;i++){
    seedBase=(seedBase*1664525+1013904223)>>>0;
    const sc=makeScene(seedBase);
    const s=scoreScene(sc);
    if(s>bestS){bestS=s; best=sc;}
    if(s>=82) break;
  }
  return best;
}

let scene=pickScene();
HISTORY.unshift(scene.feat.slice()); if(HISTORY.length>HIST_MAX) HISTORY.pop();

// ---------- Grain overlay ----------
let grainCanvas=document.createElement("canvas"), grainCtx=grainCanvas.getContext("2d",{alpha:true});
let grainPat=null;
function buildGrain(seed){
  const N=256; grainCanvas.width=grainCanvas.height=N;
  const img=grainCtx.createImageData(N,N), d=img.data;
  let s=seed>>>0;
  const rnd=()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;
  for(let i=0;i<d.length;i+=4){
    const r=rnd();
    const v=(r<0.5? r*r : 1-(1-r)*(1-r));
    const n=v-0.5;
    const a=clamp(10 + Math.abs(n)*34, 8, 46);
    d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=a;
  }
  grainCtx.putImageData(img,0,0);
  grainPat=null;
}
buildGrain(scene.seed ^ 0x9E3779B9);

function drawGrain(t){
  if(!grainPat) grainPat=gtx.createPattern(grainCanvas,"repeat");
  gtx.clearRect(0,0,W,H);
  gtx.globalAlpha=scene.grain*(0.92+0.08*Math.sin(t*2.1));
  const ox=(Math.sin(t*0.9)*3)|0, oy=(Math.cos(t*1.1)*3)|0;
  gtx.save(); gtx.translate(ox,oy);
  gtx.fillStyle=grainPat;
  gtx.fillRect(-10,-10,W+20,H+20);
  gtx.restore();
  gtx.globalAlpha=1;
}

// ---------- core render: evolving density field + flow warp ----------
function renderField(t){
  const top=scene.pal[0], mid=scene.pal[1], low=scene.pal[2], glow=scene.pal[3];
  const seed=scene.seed;

  // precompute for speed
  const invW=1/OW, invH=1/OH;
  const tt=t*scene.flow;

  let p=0;
  for(let y=0;y<OH;y++){
    const ny=y*invH;
    // vertical base gradient blend factors
    const gy=ny;
    const baseA = gy<0.65 ? gy/0.65 : 1;
    const baseB = gy<0.65 ? 0 : (gy-0.65)/0.35;

    for(let x=0;x<OW;x++){
      const nx=x*invW;

      // normalized coords in “field space”
      let X = (nx-0.5)*scene.scale*2.6;
      let Y = (ny-0.5)*scene.scale*2.6;

      // flow field (vector): time enters noise => shape evolves, not translates
      const n1 = fbm(X*0.55 + 12.3 + tt*0.35, Y*0.55 + 4.7, seed+11);
      const n2 = fbm(X*0.55 + 8.1, Y*0.55 + 15.9 + tt*0.45, seed+23);
      const ang = 6.28318*n1;
      const wx = (Math.cos(ang)*0.60 + (n2-0.5)*0.95) * scene.warp;
      const wy = (Math.sin(ang)*0.60 + (n1-0.5)*0.95) * scene.warp;

      // density (domain-warped fbm) with time offsets
      const d = fbm(X + wx + tt*0.7, Y + wy + tt*0.9, seed+101);
      const m = smoothstep(0.42, 0.78, d);
      const edge = Math.pow(m, 1.2+0.9*scene.softness);
      const lift = edge*scene.detail;

      // base color from vertical gradient
      let base;
      if(gy<0.65) base=mix3(top,mid,baseA);
      else base=mix3(mid,low,baseB);

      // lighting: warm glow lift + tiny white bloom (keeps “治愈”，不脏)
      base = mix3(base, glow, lift*scene.glow);
      base = mix3(base, [255,255,255], lift*0.05);

      // subtle atmospheric scattering variation (non-directional)
      const haze = fbm(X*0.35 + 30.7, Y*0.35 + 9.2 + tt*0.18, seed+303);
      base = mix3(base, [255,248,240], (haze-0.5)*0.08 + 0.04);

      // vignette (very light, to avoid “脏角”)
      const dx=nx-0.5, dy=ny-0.55;
      const vv = clamp(1 - (dx*dx*1.6 + dy*dy*1.8), 0, 1);
      const vfac = 1 - scene.vign*(1-vv);

      let r=(base[0]*vfac)|0, g=(base[1]*vfac)|0, b=(base[2]*vfac)|0;

      data[p++]=r; data[p++]=g; data[p++]=b; data[p++]=255;
    }
  }

  octx.putImageData(img,0,0);

  // upscale to screen (smooth)
  ctx.save();
  ctx.imageSmoothingEnabled=true;
  ctx.clearRect(0,0,W,H);
  ctx.drawImage(off,0,0,OW,OH,0,0,W,H);
  ctx.restore();
}

// ---------- switching / auto ----------
let next=null;
function scheduleNext(){
  next=null;
  let tries=0, best=null, bestS=-1;
  const step=()=>{
    // chunked to avoid jank
    for(let k=0;k<3;k++){
      tries++;
      seedBase=(seedBase*1664525+1013904223)>>>0;
      const sc=makeScene(seedBase);
      const s=scoreScene(sc);
      if(s>bestS){bestS=s; best=sc;}
      if(s>=84 || tries>=24){ next=best; return; }
    }
    setTimeout(step,0);
  };
  step();
}
function applyScene(sc){
  scene=sc;
  HISTORY.unshift(scene.feat.slice()); if(HISTORY.length>HIST_MAX) HISTORY.pop();
  buildGrain(scene.seed ^ 0x9E3779B9);
}
function switchNow(){
  if(next){ applyScene(next); next=null; scheduleNext(); }
  else { applyScene(pickScene()); scheduleNext(); }
  clearInterval(auto); auto=setInterval(switchNow,60*1000);
}
BTN.addEventListener("click",switchNow);
let auto=setInterval(switchNow,60*1000);
scheduleNext();

// ---------- main loop + adaptive quality ----------
let t=0, last=performance.now(), ema=60;
function tick(now){
  requestAnimationFrame(tick);
  const dt=now-last; last=now;
  const fps=1000/(dt||16.7); ema=ema*0.92+fps*0.08;
  t += dt*0.001;

  // adaptive resolution to keep smooth
  const target=mobile?60:90;
  if(ema<target*0.92) { q=clamp(q*0.985, mobile?0.30:0.32, 0.50); allocOff(); }
  if(ema>target*1.05) { q=clamp(q*1.004, mobile?0.30:0.32, 0.50); allocOff(); }

  renderField(t);
  drawGrain(t);

  if(((now/500)|0)%2===0){
    S.textContent=`score ${scene.score.toFixed(0)} · next ${next?next.score.toFixed(0):"…"} · fps~${ema.toFixed(0)} · q ${q.toFixed(2)}`;
  }
}
requestAnimationFrame(tick);

}catch(e){showErr(e);}
})();
</script>