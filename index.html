<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Warm Healing — Natural Clouds</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#0b0605;font:12px ui-monospace,Menlo,Consolas,monospace}
canvas{position:fixed;inset:0;display:block}
#ui{position:fixed;left:12px;right:12px;top:12px;z-index:9;display:flex;gap:10px;align-items:center;pointer-events:none;padding-top:env(safe-area-inset-top)}
#pill{flex:1;min-width:0;padding:10px 12px;border-radius:14px;border:1px solid #ffd3a855;
background:linear-gradient(90deg,#ffbf6a22,#ffd6a822,#7ad7ff12);
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset,0 16px 44px #000c;color:#ffe9d6;mix-blend-mode:screen;
text-shadow:0 0 18px #ffbf6a55,0 0 30px #ff7aa822;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#pill b{color:#fff}
#btn{pointer-events:auto;padding:10px 14px;border-radius:14px;border:1px solid #fff2;background:#0006;color:#fff;
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset}
#btn:active{transform:translateY(1px)}
</style>

<canvas id="bg"></canvas>
<canvas id="fx"></canvas>

<div id="ui">
  <div id="pill"><b>WARM HEALING</b> · <span id="s">loading…</span></div>
  <button id="btn">切换</button>
</div>

<script>
(()=>{"use strict";
const bg=document.getElementById("bg"), fx=document.getElementById("fx");
const B=bg.getContext("2d",{alpha:false}), F=fx.getContext("2d",{alpha:true});
const S=document.getElementById("s"), BTN=document.getElementById("btn");
const mobile=matchMedia("(pointer:coarse)").matches||innerWidth<760;
const clamp=(x,a,b)=>x<a?a:x>b?b:x, lerp=(a,b,t)=>a+(b-a)*t;

let W=0,H=0,DPR=1;
function resize(){
  DPR=clamp(devicePixelRatio||1,1,2); // iOS更稳，且够细腻
  W=innerWidth; H=innerHeight;
  for(const c of [bg,fx]){
    c.width=Math.max(2,Math.floor(W*DPR));
    c.height=Math.max(2,Math.floor(H*DPR));
    c.style.width=W+"px"; c.style.height=H+"px";
  }
  B.setTransform(DPR,0,0,DPR,0,0);
  F.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener("resize",resize,{passive:true});
resize();

// ---------- RNG ----------
function makeRng(seed){ let s=seed>>>0; return ()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff; }

// ---------- Color ----------
function hex2rgb(h){h=h.replace("#","");const n=parseInt(h,16);return[(n>>16)&255,(n>>8)&255,n&255];}
function rgb2hex(r,g,b){r=clamp(r|0,0,255);g=clamp(g|0,0,255);b=clamp(b|0,0,255);return"#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);}
function mixHex(a,b,t){const A=hex2rgb(a),B=hex2rgb(b);return rgb2hex(lerp(A[0],B[0],t),lerp(A[1],B[1],t),lerp(A[2],B[2],t));}
function rgb2hsv(r,g,b){
  r/=255;g/=255;b/=255;
  const mx=Math.max(r,g,b), mn=Math.min(r,g,b), d=mx-mn;
  let h=0;
  if(d){ if(mx===r) h=((g-b)/d)%6; else if(mx===g) h=(b-r)/d+2; else h=(r-g)/d+4; h/=6; if(h<0) h+=1; }
  const s=mx? d/mx:0, v=mx;
  return [h,s,v];
}

// ---------- Palettes (warm healing, no magenta/purple) ----------
const PALS=[
  ["#FFF6EE","#FFE2C2","#E5A877","#FFF9F4"],
  ["#FFF4EA","#FFDAB3","#E6A27A","#FFF8F2"],
  ["#FFF7EF","#FFE3C0","#DFA373","#FFF9F3"],
  ["#FFF3E6","#FFD6A8","#E2A06D","#FFF8F1"],
  ["#FFF6F0","#FFE0BA","#E3A16F","#FFF9F4"],
];

// ---------- Cloud noise texture (precomputed, removes banding) ----------
function hash2(ix,iy,seed){
  let x=(ix*374761393+iy*668265263)^(seed*1442695041);
  x=(x^(x>>>13))*1274126177;
  return ((x^(x>>>16))>>>0)/4294967295;
}
function noise2(x,y,seed){
  const ix=Math.floor(x), iy=Math.floor(y);
  const fx=x-ix, fy=y-iy;
  const a=hash2(ix,iy,seed), b=hash2(ix+1,iy,seed), c=hash2(ix,iy+1,seed), d=hash2(ix+1,iy+1,seed);
  const ux=fx*fx*(3-2*fx), uy=fy*fy*(3-2*fy);
  return (a*(1-ux)+b*ux)*(1-uy)+(c*(1-ux)+d*ux)*uy;
}
function fbm2(x,y,seed){
  let f=0, amp=0.5, freq=1;
  for(let i=0;i<5;i++){ f+=amp*noise2(x*freq,y*freq,seed+i*101); freq*=2; amp*=0.5; }
  return f;
}
let cloudTex=null, cloudPat=null, cloudSeed=1;
function buildCloudTex(seed){
  cloudSeed=seed>>>0;
  const N=256;
  const c=document.createElement("canvas"); c.width=c.height=N;
  const ctx=c.getContext("2d",{alpha:false});
  const img=ctx.createImageData(N,N), d=img.data;
  for(let y=0;y<N;y++){
    for(let x=0;x<N;x++){
      // fbm cloud: smooth, no stripes
      const nx=x/N, ny=y/N;
      const v=fbm2(nx*2.2, ny*2.2, cloudSeed);
      // contrast curve to get “cloud body”
      const t=clamp((v-0.45)/0.30,0,1);
      const c2=t*t*(3-2*t); // smoothstep
      const g=(c2*255)|0;
      const i=(y*N+x)*4;
      d[i]=g; d[i+1]=g; d[i+2]=g; d[i+3]=255;
    }
  }
  ctx.putImageData(img,0,0);
  cloudTex=c; cloudPat=null;
}
function getCloudPat(){
  if(!cloudPat) cloudPat=B.createPattern(cloudTex,"repeat");
  return cloudPat;
}

// ---------- Grain / dithering (stronger to kill iOS banding, still subtle) ----------
let grainTex=null, grainPat=null, grainSeed=1;
function buildGrain(seed){
  grainSeed=seed>>>0;
  const N=256;
  const c=document.createElement("canvas"); c.width=c.height=N;
  const ctx=c.getContext("2d",{alpha:true});
  const img=ctx.createImageData(N,N), d=img.data;
  let s=grainSeed;
  const rnd=()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;
  for(let i=0;i<d.length;i+=4){
    const r=rnd();
    const v=(r<0.5? r*r : 1-(1-r)*(1-r)); // fewer extremes
    const n=(v-0.5);
    // luma-only dithering (no color noise)
    const a=clamp(12 + Math.abs(n)*36, 10, 52);
    d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=a;
  }
  ctx.putImageData(img,0,0);
  grainTex=c; grainPat=null;
}
function drawGrain(time,amount){
  if(!grainPat) grainPat=F.createPattern(grainTex,"repeat");
  F.clearRect(0,0,W,H);
  F.globalAlpha=amount*(0.92+0.08*Math.sin(time*2.0));
  const ox=(Math.sin(time*0.9)*3)|0, oy=(Math.cos(time*1.1)*3)|0;
  F.save(); F.translate(ox,oy);
  F.fillStyle=grainPat;
  F.fillRect(-10,-10,W+20,H+20);
  F.restore();
  F.globalAlpha=1;
}

// ---------- Candidate ----------
function genCandidate(seed){
  const rnd=makeRng(seed);
  const base=PALS[(rnd()*PALS.length)|0];

  // dynamics (stronger than before but still “background-safe”)
  const cloudA=0.10+0.16*rnd();         // cloud contrast strength
  const cloudS=0.75+1.35*rnd();         // cloud scale
  const cloudV=0.006+0.015*rnd();       // cloud time speed (slow)
  const rippleA=0.02+0.05*rnd();        // water-caustics very subtle
  const rippleS=0.8+1.8*rnd();
  const rippleV=0.12+0.22*rnd();
  const warmth=0.06+0.10*rnd();         // warm lift
  const vign=0.06+0.12*rnd();           // very light vignette
  const grain=0.050+0.030*rnd();        // stronger to fight banding
  const feat=[cloudA,cloudS,rippleA,rippleS,warmth,vign,grain];
  return {seed,base,cloudA,cloudS,cloudV,rippleA,rippleS,rippleV,warmth,vign,grain,feat,score:0,breakdown:null};
}

// ---------- Render ----------
function render(ctx,w,h,c,t){
  const [top,mid,low,glow]=c.base;
  const breathe=0.5+0.5*Math.sin(t*0.16);
  const drift  =0.5+0.5*Math.sin(t*0.07+1.7);

  // warm lift prevents “muddy gray”
  const top2=mixHex(top, glow, c.warmth*(0.55+0.45*breathe));
  const mid2=mixHex(mid, glow, c.warmth*(0.35+0.65*drift));
  const low2=mixHex(low, glow, c.warmth*(0.25+0.55*breathe));

  // base gradient (very smooth)
  const sky=ctx.createLinearGradient(0,0,0,h);
  sky.addColorStop(0, top2);
  sky.addColorStop(0.65, mid2);
  sky.addColorStop(1, low2);
  ctx.fillStyle=sky; ctx.fillRect(0,0,w,h);

  // cloud texture layer: pattern moved slowly (no stripes, natural)
  ctx.save();
  ctx.globalCompositeOperation="soft-light";
  ctx.globalAlpha=0.65;
  const pat=getCloudPat();

  // transform pattern for scale + drift
  // We draw a big rect with translated pattern to simulate moving cloud mass.
  const sx = (1/(c.cloudS))*w/256;
  const sy = (1/(c.cloudS))*h/256;
  const dx = (Math.sin(t*c.cloudV*6.0)*0.06 + Math.sin(t*0.03))*w;
  const dy = (Math.cos(t*c.cloudV*5.0)*0.05 + Math.cos(t*0.028))*h;

  // paint pattern
  ctx.translate(dx,dy);
  ctx.scale(sx,sy);
  ctx.fillStyle=pat;
  ctx.fillRect(-512,-512, (w/sx)+1024, (h/sy)+1024);
  ctx.restore();

  // cloud contrast shaping: overlay a radial “light well” to give depth hierarchy
  ctx.globalCompositeOperation="soft-light";
  const cx=w*0.35, cy=h*0.25, rr=Math.max(w,h)*0.90;
  const halo=ctx.createRadialGradient(cx,cy,0,cx,cy,rr);
  halo.addColorStop(0,`rgba(255,255,255,${0.10+0.08*breathe})`);
  halo.addColorStop(0.7,`rgba(255,246,235,${0.06+0.05*drift})`);
  halo.addColorStop(1,"rgba(255,255,255,0)");
  ctx.fillStyle=halo; ctx.fillRect(0,0,w,h);

  // water-caustics hint: very subtle diagonal shimmer (no hard bands)
  ctx.globalCompositeOperation="overlay";
  ctx.globalAlpha=0.20;
  for(let i=0;i<4;i++){
    const p=(i/4);
    const ph=t*c.rippleV + p*2.3;
    const a=c.rippleA*(0.45+0.55*(0.5+0.5*Math.sin(ph)));
    const xoff=(Math.sin(ph*0.9)*0.08)*w;
    const y0=(p*h) + (Math.cos(ph)*0.05)*h;
    const grad=ctx.createLinearGradient(xoff,y0, xoff+w*0.9, y0+h*0.25);
    grad.addColorStop(0,`rgba(255,255,255,0)`);
    grad.addColorStop(0.45,`rgba(255,255,255,${a})`);
    grad.addColorStop(1,`rgba(255,255,255,0)`);
    ctx.fillStyle=grad;
    ctx.fillRect(0,y0-h*0.15,w,h*0.45);
  }
  ctx.globalAlpha=1;

  // vignette (very light, avoids “dirt corners”)
  ctx.globalCompositeOperation="multiply";
  const v=ctx.createRadialGradient(w*0.5,h*0.55,Math.min(w,h)*0.30,w*0.5,h*0.55,Math.max(w,h)*0.95);
  const vv=c.vign*(0.85+0.15*breathe);
  v.addColorStop(0,"rgba(0,0,0,0)");
  v.addColorStop(1,`rgba(0,0,0,${vv})`);
  ctx.fillStyle=v; ctx.fillRect(0,0,w,h);

  ctx.globalCompositeOperation="source-over";
}

// ---------- Scoring (multi-factor + anti-homogenization) ----------
const PRE=72, pre=document.createElement("canvas"); pre.width=pre.height=PRE;
const P=pre.getContext("2d",{alpha:false});
function analyze(img){
  const d=img.data, n=img.width*img.height;
  let warm=0,purple=0,dark=0,hot=0,muddy=0,satSum=0,lumSum=0,lum2=0;
  let grad=0, mid=0, hi=0;

  const lum=(r,g,b)=>0.2126*r+0.7152*g+0.0722*b;

  for(let y=0;y<img.height;y++)for(let x=0;x<img.width;x++){
    const i=(y*img.width+x)*4;
    const r=d[i], g=d[i+1], b=d[i+2];
    const L=lum(r/255,g/255,b/255);
    lumSum+=L; lum2+=L*L;
    const [h,s,v]=rgb2hsv(r,g,b); satSum+=s;

    if((h>=0 && h<=70/360) || (h>=0.98 && h<=1)) warm++;
    if(h>=255/360 && h<=330/360) purple++;
    if(L<0.10) dark++;
    if(L>0.92 && s>0.55) hot++;

    if(s>0.12 && s<0.45 && L>0.30 && L<0.78){
      const rg=Math.abs(r-g)/255, rb=Math.abs(r-b)/255, gb=Math.abs(g-b)/255;
      if(rg<0.06 && rb<0.06 && gb<0.06) muddy++;
    }

    if(x>0){
      const j=i-4;
      const L2=lum(d[j]/255,d[j+1]/255,d[j+2]/255);
      const dl=Math.abs(L-L2); grad+=dl; if(dl>0.22) hi++;
    }
    if(y>0){
      const j=i-img.width*4;
      const L2=lum(d[j]/255,d[j+1]/255,d[j+2]/255);
      const dl=Math.abs(L-L2); grad+=dl; if(dl>0.22) hi++;
    }
    if(x>2){
      const j=i-8; const L2=lum(d[j]/255,d[j+1]/255,d[j+2]/255);
      mid+=Math.abs(L-L2);
    }
    if(y>2){
      const j=i-img.width*8; const L2=lum(d[j]/255,d[j+1]/255,d[j+2]/255);
      mid+=Math.abs(L-L2);
    }
  }

  const warmP=warm/n, purpleP=purple/n, darkP=dark/n, hotP=hot/n, muddyP=muddy/n;
  const lumMean=lumSum/n, lumStd=Math.sqrt(Math.max(0, lum2/n - lumMean*lumMean));
  const satMean=satSum/n;
  const gradMean=grad/(n*2), midMean=mid/(n*2), hiP=hi/(n*2);
  return {warmP,purpleP,darkP,hotP,muddyP,lumMean,lumStd,satMean,gradMean,midMean,hiP};
}
const HISTORY=[], HIST_MAX=10;
function similarity(a,b){
  let dot=0,na=0,nb=0;
  for(let i=0;i<a.length;i++){ dot+=a[i]*b[i]; na+=a[i]*a[i]; nb+=b[i]*b[i]; }
  return dot/Math.sqrt((na*nb)+1e-9);
}
function scoreCandidate(c){
  const times=[0.8,2.2,3.7];
  let sum=0, best=0, breakdown=null;

  for(const tt of times){
    P.setTransform(1,0,0,1,0,0);
    render(P,PRE,PRE,c,tt);
    const a=analyze(P.getImageData(0,0,PRE,PRE));

    const sWarm=100*clamp((a.warmP-0.62)/0.26,0,1);
    const sLum =100*Math.exp(-Math.pow((a.lumMean-0.60)/0.14,2));
    const sCon =100*Math.exp(-Math.pow((a.lumStd-0.16)/0.08,2));
    const sSat =100*Math.exp(-Math.pow((a.satMean-0.42)/0.16,2));
    const sMid =100*clamp((a.midMean-0.030)/0.055,0,1);

    const pMud =100*clamp((a.muddyP-0.05)/0.14,0,1);
    const pPur =100*clamp((a.purpleP-0.006)/0.03,0,1);
    const pDark=100*clamp((a.darkP-0.06)/0.18,0,1);
    const pHot =100*clamp((a.hotP-0.03)/0.10,0,1);
    const pHi  =100*clamp((a.hiP-0.012)/0.05,0,1);

    // 目标：自然舒适（亮度/温暖优先），纹理只要“有空气感”，不需要夸张
    let s =
      0.22*sWarm + 0.22*sLum + 0.10*sCon + 0.10*sSat + 0.12*sMid
      - 0.18*pMud - 0.18*pPur - 0.06*pDark - 0.05*pHot - 0.05*pHi;

    s=clamp(s,0,100);
    sum+=s; if(s>best) best=s;
    if(tt===2.2) breakdown={sWarm,sLum,sCon,sSat,sMid,pMud,pPur,pDark,pHot,pHi,raw:a};
  }

  let score=(sum/times.length)*0.70 + best*0.30;

  if(HISTORY.length){
    let simMax=0;
    for(const f of HISTORY) simMax=Math.max(simMax, similarity(c.feat,f));
    score -= 18*clamp((simMax-0.92)/0.08,0,1);
  }

  c.score=clamp(score,0,100);
  c.breakdown=breakdown;
  return c.score;
}

// ---------- Selection / scheduling ----------
let seedBase=123456789, current=null, next=null;
function findHigh(maxTry=22, threshold=84){
  let best=null, bestS=-1;
  for(let i=0;i<maxTry;i++){
    seedBase=(seedBase*1664525+1013904223)>>>0;
    const c=genCandidate(seedBase);
    const s=scoreCandidate(c);
    if(s>bestS){bestS=s; best=c;}
    if(s>=threshold) return c;
  }
  return best;
}
function apply(c){
  current=c;
  // textures depend on seed -> variety without color chaos
  buildCloudTex(c.seed ^ 0xA53A1F3);
  buildGrain(c.seed ^ 0x9E3779B9);
  HISTORY.unshift(c.feat.slice()); if(HISTORY.length>HIST_MAX) HISTORY.pop();
}
function scheduleNext(){
  let tries=0, best=null, bestS=-1;
  const step=()=>{
    const batch=2;
    for(let k=0;k<batch;k++){
      tries++;
      seedBase=(seedBase*1664525+1013904223)>>>0;
      const c=genCandidate(seedBase);
      const s=scoreCandidate(c);
      if(s>bestS){bestS=s; best=c;}
      if(s>=86 || tries>=28){ next=best; return; }
    }
    setTimeout(step,0);
  };
  next=null; step();
}
function switchNow(){
  if(next){ apply(next); next=null; scheduleNext(); }
  else { apply(findHigh(18,84)); scheduleNext(); }
  clearInterval(auto); auto=setInterval(()=>switchNow(),60*1000);
}
BTN.addEventListener("click",switchNow);
let auto=setInterval(()=>switchNow(),60*1000);

// ---------- Main loop ----------
let last=performance.now(), t=0, ema=60, scale=1;
apply(findHigh(22,84));
scheduleNext();

function draw(now){
  requestAnimationFrame(draw);
  const dt=now-last; last=now;
  const fps=1000/(dt||16.7); ema=ema*0.92+fps*0.08;
  t += dt*0.001;

  const target=mobile?60:90;
  if(ema<target*0.92) scale=clamp(scale*0.985,0.82,1);
  if(ema>target*1.03) scale=clamp(scale*1.003,0.82,1);

  const wantW=Math.floor(W*DPR*scale), wantH=Math.floor(H*DPR*scale);
  if(Math.abs(bg.width-wantW)>3 || Math.abs(bg.height-wantH)>3){
    for(const c of [bg,fx]){ c.width=wantW; c.height=wantH; }
  }
  const sx=bg.width/W, sy=bg.height/H;
  B.setTransform(sx,0,0,sy,0,0);
  F.setTransform(sx,0,0,sy,0,0);

  render(B,W,H,current,t);
  drawGrain(t,current.grain);

  if(((now/500)|0)%2===0){
    const sc=current.score?.toFixed(0) ?? "--";
    const nx=next?.score!=null?next.score.toFixed(0):"…";
    S.textContent=`score ${sc} · next ${nx} · fps~${ema.toFixed(0)} · clouds ${current.cloudA.toFixed(2)} · ripple ${current.rippleA.toFixed(2)}`;
  }
}
requestAnimationFrame(draw);
})();
</script>