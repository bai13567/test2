<!doctype html>
<html lang="zh">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Procedural Volumetric Clouds (No Textures)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#eef6ff}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}
  #err{
    position:fixed;left:12px;top:12px;right:12px;max-height:45vh;overflow:auto;
    padding:10px 12px;border-radius:10px;background:rgba(0,0,0,.75);color:#fff;
    font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;display:none;z-index:9;
    white-space:pre-wrap;word-break:break-word;
  }
</style>
<canvas id="c"></canvas>
<div id="err"></div>

<script>
(()=> {
  const c = document.getElementById("c");
  const err = document.getElementById("err");

  function showErr(s){
    err.style.display="block";
    err.textContent = String(s||"Unknown error");
    console.error(s);
  }

  const gl = c.getContext("webgl",{antialias:false,alpha:false,premultipliedAlpha:false,depth:false,stencil:false});
  if(!gl){
    const g=c.getContext("2d"); if(!g) return;
    g.fillStyle="#000"; g.font="16px system-ui";
    g.fillText("WebGL not supported",20,30);
    return;
  }

  // Vertex: fullscreen quad
  const V = `
    attribute vec2 p;
    void main(){ gl_Position = vec4(p,0.0,1.0); }
  `;

  // Fragment: procedural volumetric clouds (no textures)
  const F = `
  precision highp float;
  uniform vec2  r;
  uniform float t;

  // --------- small helpers ----------
  float sat(float x){ return clamp(x,0.0,1.0); }
  vec3  sat3(vec3 x){ return clamp(x,0.0,1.0); }

  // Hash (no textures)
  float hash31(vec3 p){
    p = fract(p*0.1031);
    p += dot(p, p.yzx + 33.33);
    return fract((p.x + p.y) * p.z);
  }

  // 3D value noise (trilinear)
  float noise3(vec3 p){
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f*f*(3.0-2.0*f);

    float n000 = hash31(i + vec3(0,0,0));
    float n100 = hash31(i + vec3(1,0,0));
    float n010 = hash31(i + vec3(0,1,0));
    float n110 = hash31(i + vec3(1,1,0));
    float n001 = hash31(i + vec3(0,0,1));
    float n101 = hash31(i + vec3(1,0,1));
    float n011 = hash31(i + vec3(0,1,1));
    float n111 = hash31(i + vec3(1,1,1));

    float nx00 = mix(n000,n100,f.x);
    float nx10 = mix(n010,n110,f.x);
    float nx01 = mix(n001,n101,f.x);
    float nx11 = mix(n011,n111,f.x);

    float nxy0 = mix(nx00,nx10,f.y);
    float nxy1 = mix(nx01,nx11,f.y);

    return mix(nxy0,nxy1,f.z);
  }

  // fBm (kept small for iOS)
  float fbm3(vec3 p){
    float v = 0.0;
    float a = 0.56;
    // 5 octaves: good quality / still mobile friendly
    for(int i=0;i<5;i++){
      v += a * noise3(p);
      p = p*1.92 + vec3(19.7, 7.3, 13.1);
      a *= 0.52;
    }
    return v;
  }

  // Ridged-ish detail for erosion (cheap)
  float ridged(vec3 p){
    float n = fbm3(p);
    n = 1.0 - abs(2.0*n - 1.0);
    return n*n;
  }

  // Henyey-Greenstein phase (single scattering approx)
  float phaseHG(float cosTheta, float g){
    float gg = g*g;
    float d = 1.0 + gg - 2.0*g*cosTheta;
    return (1.0 - gg) / (4.0*3.14159265*pow(d, 1.5));
  }

  // Height profile: bottom thick, top thinner
  float heightProfile(float h){
    // h in [0..1]
    float base = smoothstep(0.02, 0.18, h);
    float top  = 1.0 - smoothstep(0.62, 0.98, h);
    return base * top;
  }

  // Procedural density field (2.5D -> true 3D sampling)
  float cloudDensity(vec3 P){
    // World scale
    vec3 p = P;

    // Domain warp: makes “billows”
    vec3 w;
    w.x = fbm3(p*0.55 + vec3(0.0, 0.0, t*0.06));
    w.y = fbm3(p*0.55 + vec3(9.1, 3.7, t*0.05));
    w.z = fbm3(p*0.55 + vec3(2.8, 7.9, t*0.04));
    p += (w - 0.5) * 0.85;

    // Main shape (low freq)
    float d0 = fbm3(p*0.85 + vec3(t*0.02, t*0.01, 0.0));

    // Detail (higher freq)
    float d1 = fbm3(p*1.95 - vec3(t*0.03, 0.0, t*0.02));

    float dens = d0*0.78 + d1*0.22;

    // Height layering: P.y defines altitude
    float h = sat((P.y - 0.15) / 0.95); // map to [0..1] in our scene
    dens *= heightProfile(h);

    // Erosion: chew edges and cloud tops
    float er = ridged(p*3.2 + vec3(0.0, t*0.08, 0.0));
    // stronger erosion near top
    float et = mix(0.10, 0.42, smoothstep(0.45, 0.95, h));
    dens -= er * et;

    // Threshold + shaping (prevents “fog sheet”)
    dens = smoothstep(0.46, 0.78, dens);
    dens = pow(dens, 1.15);

    return sat(dens);
  }

  // Shadow along sun direction (few steps)
  float shadowToSun(vec3 P, vec3 L){
    float s = 1.0;
    float dist = 0.0;
    // 4 steps: cheap shadowing
    for(int i=0;i<4;i++){
      dist += 0.18 + 0.06*float(i);
      float d = cloudDensity(P + L*dist);
      // exponential attenuation
      s *= exp(-d * 1.65);
      if(s < 0.20) break;
    }
    return sat(s);
  }

  void main(){
    vec2 uv = (gl_FragCoord.xy / r);
    vec2 p = uv*2.0 - 1.0;
    p.x *= r.x / r.y;

    // Camera setup (simple)
    vec3 ro = vec3(0.0, 0.55, 2.2);        // origin
    vec3 rd = normalize(vec3(p.x, p.y*0.85, -1.35)); // direction

    // Sun direction
    vec3 sunDir = normalize(vec3(0.55, 0.42, -0.20));

    // Sky background
    vec3 skyTop = vec3(0.84, 0.93, 1.00);
    vec3 skyBot = vec3(0.96, 0.98, 1.00);
    float skyT = sat(p.y*0.55 + 0.55);
    vec3 sky = mix(skyBot, skyTop, skyT);

    // Raymarch within a slab (cloud layer bounds)
    // We intersect a simple y-range slab: [yMin,yMax]
    float yMin = 0.10;
    float yMax = 1.10;

    // Find t range where ray is inside [yMin,yMax]
    // Solve ro.y + rd.y * s in [yMin,yMax]
    float invY = 1.0 / max(abs(rd.y), 1e-4);
    float s1 = (yMin - ro.y) * invY * sign(rd.y);
    float s2 = (yMax - ro.y) * invY * sign(rd.y);
    float sNear = min(s1,s2);
    float sFar  = max(s1,s2);

    // Also clamp to forward ray
    float sStart = max(sNear, 0.0);
    float sEnd   = max(sFar,  0.0);

    // If not intersecting slab, just show sky
    if(sEnd <= sStart){
      gl_FragColor = vec4(sat3(pow(sky, vec3(0.98))), 1.0);
      return;
    }

    // Integrate
    vec3 col = vec3(0.0);
    float T = 1.0; // transmittance
    float s = sStart;

    // Base step adapts with view angle (more steps on horizon)
    float horizon = pow(1.0 - sat(abs(rd.y)), 1.25);
    float baseStep = mix(0.22, 0.14, horizon);

    // Constants (tuned for “white cloud”)
    float absorption = 1.35;
    float scatterStrength = 1.10;

    // 10 max steps, early-out
    for(int i=0;i<10;i++){
      if(s > sEnd || T < 0.02) break;

      vec3 P = ro + rd*s;

      float d = cloudDensity(P);

      // Adaptive step: low density -> larger step
      float stepLen = baseStep * mix(1.35, 0.72, d);

      // Light
      float cosTheta = dot(rd, sunDir) * -1.0; // scattering angle (view vs sun)
      float phase = phaseHG(cosTheta, 0.62);   // forward-ish
      float sh = shadowToSun(P, sunDir);

      // Ambient from sky: more at top
      float h = sat((P.y - yMin) / (yMax - yMin));
      vec3 ambient = mix(vec3(0.70,0.84,1.00), vec3(1.00,0.99,0.97), 0.30 + 0.70*h);

      // Sun color slightly warm
      vec3 sunCol = vec3(1.00, 0.98, 0.93);

      // Single-scatter approximation
      vec3 light = ambient * (0.55 + 0.45*(1.0 - d)) + sunCol * (0.90*sh) * phase * 7.5;

      // Beer-Lambert
      float att = exp(-d * absorption * stepLen);

      // Accumulate (premultiplied style)
      vec3 scatter = d * scatterStrength * light;
      col += T * (1.0 - att) * scatter;

      // Update transmittance
      T *= att;

      s += stepLen;
    }

    // Edge translucency / silverlining from physics result (T)
    float edge = pow(1.0 - T, 0.85);
    vec3 edgeCol = vec3(1.0) * (0.10 + 0.22*edge);

    // Composite with sky
    vec3 outCol = sky * T + col + edgeCol * edge;

    // Gentle tonemap / gamma
    outCol = outCol / (1.0 + outCol*0.65);
    outCol = pow(sat3(outCol), vec3(0.98));

    gl_FragColor = vec4(outCol, 1.0);
  }`;

  function sh(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      const info = gl.getShaderInfoLog(s) || "Shader compile failed";
      throw new Error(info);
    }
    return s;
  }

  let P;
  try{
    P = gl.createProgram();
    gl.attachShader(P, sh(gl.VERTEX_SHADER, V));
    gl.attachShader(P, sh(gl.FRAGMENT_SHADER, F));
    gl.linkProgram(P);
    if(!gl.getProgramParameter(P, gl.LINK_STATUS)){
      throw new Error(gl.getProgramInfoLog(P) || "Program link failed");
    }
    gl.useProgram(P);
  }catch(e){
    showErr(e && e.message ? e.message : e);
    return;
  }

  // Fullscreen quad buffer
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]), gl.STATIC_DRAW);

  const locP = gl.getAttribLocation(P, "p");
  gl.enableVertexAttribArray(locP);
  gl.vertexAttribPointer(locP, 2, gl.FLOAT, false, 0, 0);

  const ur = gl.getUniformLocation(P, "r");
  const ut = gl.getUniformLocation(P, "t");

  // iOS-friendly render scale: keep it stable & fast
  const RENDER_SCALE = 0.78; // 0.65~0.9 可自行改，越大越清晰越费

  function resize(){
    const dpr = Math.min(2, (devicePixelRatio||1));
    const vw = (visualViewport ? visualViewport.width  : innerWidth);
    const vh = (visualViewport ? visualViewport.height : innerHeight);

    const w = Math.max(1, Math.floor(vw * dpr * RENDER_SCALE));
    const h = Math.max(1, Math.floor(vh * dpr * RENDER_SCALE));

    if(c.width !== w || c.height !== h){
      c.width = w; c.height = h;
      gl.viewport(0,0,w,h);
      gl.uniform2f(ur, w, h);
    }
  }
  addEventListener("resize", resize, {passive:true});
  if(visualViewport) visualViewport.addEventListener("resize", resize, {passive:true});
  resize();

  let t0 = performance.now();
  let paused = false;
  document.addEventListener("visibilitychange", ()=>paused=document.hidden, {passive:true});

  (function loop(now){
    if(!paused){
      gl.uniform1f(ut, (now - t0) * 0.001);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    requestAnimationFrame(loop);
  })(t0);

})();
</script>
</html>