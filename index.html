<!doctype html><meta charset="utf-8"><meta name="viewport"content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Neon Rift X (iOS-safe)</title>
<style>
html,body{margin:0;height:100%;background:#05060a;overflow:hidden;font:12px ui-monospace,Menlo,Consolas,monospace}
#ui{position:fixed;inset:12px 12px auto 12px;z-index:9;display:flex;gap:10px;align-items:center;color:#d7e3ff;mix-blend-mode:screen}
#pill{flex:1;min-width:0;padding:10px 12px;border-radius:14px;border:1px solid #7af5;background:linear-gradient(90deg,#1a2bff22,#ff2bd722);
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset,0 14px 40px #000b;text-shadow:0 0 14px #7af,0 0 30px #f0f}
#pill b{color:#fff}#pill small{display:block;opacity:.85;margin-top:6px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#btn{padding:10px 12px;border-radius:14px;border:1px solid #fff2;background:#0006;color:#fff;backdrop-filter:blur(12px)}
#btn:active{transform:translateY(1px)}
body:before{content:"";position:fixed;inset:-60px;pointer-events:none;background:
repeating-linear-gradient(0deg,rgba(255,255,255,.045),rgba(255,255,255,.045) 1px,transparent 2px,transparent 5px);
mix-blend-mode:overlay;opacity:.30;animation:scan 7s linear infinite}
@keyframes scan{to{transform:translateY(60px)}}
canvas{display:block}
</style>
<div id=ui><div id=pill><b>NEON RIFT X</b> · <span id=s>loading…</span>
<small>单指=涡旋 · 双指=缩放+平移 · BOOM=震荡+特效拉满（自适应性能）</small></div><button id=btn>BOOM</button></div>

<script type="module">
/* 语言元素（额外 3 种以上）：GLSL + JSON + SVG(滤镜) */
const GLSL=`void main(){gl_FragColor=vec4(1.);}`; // 占位展示
const CFG={"dprCap":1.8,"mobileDprCap":1.55,"pDesktop":90000,"pMobile":60000}; // JSON
const SVG=`<svg><filter id="glow"><feGaussianBlur stdDeviation="2"/></filter></svg>`; // SVG(字符串展示)

import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
import { EffectComposer } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/RenderPass.js";
import { ShaderPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/ShaderPass.js";
import { AfterimagePass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/AfterimagePass.js";
import { UnrealBloomPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js";
import { GlitchPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/GlitchPass.js";
import { FilmPass } from "https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/FilmPass.js";
import { RGBShiftShader } from "https://unpkg.com/three@0.161.0/examples/jsm/shaders/RGBShiftShader.js";

const S=document.getElementById("s"),BTN=document.getElementById("btn");
const mobile=matchMedia("(pointer:coarse)").matches||innerWidth<760;
const clamp=(x,a,b)=>x<a?a:x>b?b:x;

let DPR=clamp(devicePixelRatio||1,1,mobile?CFG.mobileDprCap:CFG.dprCap),W=innerWidth,H=innerHeight;
let zoom=1,panx=0,pany=0,boom=0,md=0,t=0,px=0,py=0,quality=1,ema=60;
let touches=new Map(),pinch0=0,zoom0=1,pan0=[0,0],cent0=[0,0];

const r=new THREE.WebGLRenderer({antialias:false,alpha:false,powerPreference:"high-performance"});
r.setClearColor(0x05060a,1);r.setPixelRatio(DPR);r.setSize(W,H);
document.body.appendChild(r.domElement);

const scene=new THREE.Scene();
const cam=new THREE.PerspectiveCamera(55,W/H,0.01,30);cam.position.set(0,0,2.3);

/* 背景 Shader（稳定写法：普通 plane + ShaderMaterial） */
const bg=new THREE.Mesh(new THREE.PlaneGeometry(2,2),
new THREE.ShaderMaterial({
  depthWrite:false,depthTest:false,
  uniforms:{R:{value:new THREE.Vector2(W*DPR,H*DPR)},T:{value:0},M:{value:new THREE.Vector2(0,0)},Z:{value:1},P:{value:new THREE.Vector2(0,0)},B:{value:0}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`precision highp float;varying vec2 vUv;uniform vec2 R;uniform float T;uniform vec2 M;uniform float Z;uniform vec2 P;uniform float B;
float h(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);}
float n(vec2 p){vec2 i=floor(p),f=fract(p);vec2 u=f*f*(3.0-2.0*f);
return mix(mix(h(i),h(i+vec2(1,0)),u.x),mix(h(i+vec2(0,1)),h(i+vec2(1,1)),u.x),u.y);}
float fbm(vec2 p){float f=0.,a=.5;for(int i=0;i<5;i++){f+=a*n(p);p*=2.;a*=.5;}return f;}
void main(){
  vec2 uv=(gl_FragCoord.xy-0.5*R)/R.y; uv*=Z; uv-=P;
  float d=length(uv-M*0.9)+1e-4; float w=exp(-d*3.2);
  float a=atan(uv.y,uv.x),r=length(uv);
  float z=fbm(uv*2.8+vec2(T*.06,-T*.04));
  float z2=fbm(uv*4.2-vec2(T*.04,T*.02));
  float rip=sin(r*10.-T*2.0 + B*8.)*0.10;
  vec3 col=vec3(.03,.06,.14);
  col += vec3(.10,.35,.95)*(0.2+0.8*z);
  col += vec3(.95,.10,.85)*(0.2+0.8*z2);
  col += w*vec3(.25,.8,1.25);
  col += (0.5+0.5*sin(a*6.+T*0.9))*0.05;
  col += rip*vec3(.2,.6,1.0);
  col *= 1.0 + B*0.25;
  gl_FragColor=vec4(col,1.0);
}`}));
bg.frustumCulled=false;scene.add(bg);

/* 粒子：用 Points（iOS 最稳），位置用 BufferAttribute（不搞 instancing 花活） */
let count=mobile?CFG.pMobile:CFG.pDesktop;
let pos=new Float32Array(count*3),vel=new Float32Array(count*2),hue=new Float32Array(count);
for(let i=0;i<count;i++){pos[i*3]=(Math.random()*2-1);pos[i*3+1]=(Math.random()*2-1);pos[i*3+2]=0;
vel[i*2]=0;vel[i*2+1]=0;hue[i]=Math.random();}
const geom=new THREE.BufferGeometry();
geom.setAttribute("position",new THREE.BufferAttribute(pos,3));
geom.setAttribute("aHue",new THREE.BufferAttribute(hue,1));
const mat=new THREE.ShaderMaterial({
  transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
  uniforms:{T:{value:0},Z:{value:1},P:{value:new THREE.Vector2(0,0)},M:{value:new THREE.Vector2(0,0)},B:{value:0}},
  vertexShader:`uniform float T;uniform float Z;uniform vec2 P;uniform vec2 M;uniform float B;
attribute float aHue;varying float vHue;varying float vA;
void main(){
  vec3 p=position; p.xy/=Z; p.xy+=P;
  vec2 d=p.xy-(M*0.35); float r=dot(d,d)+1e-3; float inv=inversesqrt(r);
  float sz=(2.0 + 10.0*(0.5+0.5*sin(aHue*6.283+T*1.6)) + B*9.0) / Z;
  vHue=aHue; vA=clamp(0.12+inv*0.12,0.10,0.65);
  gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);
  gl_PointSize=sz;
}`,
  fragmentShader:`precision highp float;uniform float T;uniform float B;varying float vHue;varying float vA;
vec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}
void main(){
  vec2 uv=gl_PointCoord*2.-1.; float d=dot(uv,uv);
  float a=exp(-d*2.6);
  vec3 col=hsv2rgb(vec3(fract(vHue+T*0.02),1.,1.));
  col=mix(col,vec3(.55,.85,1.2),0.35);
  col*=1.0+B*0.35;
  gl_FragColor=vec4(col,a*vA);
}`});
const pts=new THREE.Points(geom,mat);scene.add(pts);

/* 后处理（three 官方 examples：iOS Safari 更稳） */
const composer=new EffectComposer(r);
composer.addPass(new RenderPass(scene,cam));
const bloom=new UnrealBloomPass(new THREE.Vector2(W,H),1.2,0.7,0.05); composer.addPass(bloom);
const after=new AfterimagePass(0.88); composer.addPass(after);
const rgb=new ShaderPass(RGBShiftShader); rgb.uniforms["amount"].value=0.0016; composer.addPass(rgb);
const film=new FilmPass(0.35,0.5,720,false); composer.addPass(film);
const glitch=new GlitchPass(); glitch.enabled=true; composer.addPass(glitch);

/* WebAudio：iOS 需要用户手势 */
let AC;const beep=(k=1)=>{try{AC||(AC=new (window.AudioContext||window.webkitAudioContext)());
const o=AC.createOscillator(),g=AC.createGain();o.type="sawtooth";o.frequency.value=160+Math.random()*240;
g.gain.setValueAtTime(0.0001,AC.currentTime);g.gain.exponentialRampToValueAtTime(0.10*k,AC.currentTime+.01);
g.gain.exponentialRampToValueAtTime(0.0001,AC.currentTime+.22);o.connect(g);g.connect(AC.destination);o.start();o.stop(AC.currentTime+.24);}catch(e){}};
const boomNow=()=>{boom=1;beep(1.25)}; BTN.onclick=boomNow; addEventListener("keydown",e=>e.code==="Space"&&boomNow());

function setM(cx,cy){px=(cx/innerWidth-.5)*1.6;py=(cy/innerHeight-.5)*1.6}
function dist(a,b){let dx=a.x-b.x,dy=a.y-b.y;return Math.hypot(dx,dy)}
function center(a,b){return {x:(a.x+b.x)/2,y:(a.y+b.y)/2}}

addEventListener("pointerdown",e=>{
  r.domElement.setPointerCapture(e.pointerId);
  touches.set(e.pointerId,{x:e.clientX,y:e.clientY});
  md=touches.size===1;
  if(touches.size===1) setM(e.clientX,e.clientY);
  if(touches.size===2){
    let [p1,p2]=[...touches.values()];pinch0=dist(p1,p2);zoom0=zoom;pan0=[panx,pany];
    let ce=center(p1,p2);cent0=[ce.x,ce.y];
  }
},{passive:false});
addEventListener("pointermove",e=>{
  if(!touches.has(e.pointerId))return;
  let p=touches.get(e.pointerId);p.x=e.clientX;p.y=e.clientY;
  if(touches.size===1){let q=[...touches.values()][0];setM(q.x,q.y)}
  else if(touches.size===2){
    let [p1,p2]=[...touches.values()],d=dist(p1,p2);
    zoom=clamp(zoom0*(d/(pinch0||d)),.55,2.7);
    let ce=center(p1,p2);
    panx=pan0[0]+((ce.x-cent0[0])/innerWidth)*1.6;
    pany=pan0[1]+((ce.y-cent0[1])/innerHeight)*1.6;
  }
},{passive:false});
addEventListener("pointerup",e=>{touches.delete(e.pointerId);md=touches.size===1;});
addEventListener("pointercancel",()=>{touches.clear();md=0;});
addEventListener("wheel",e=>{zoom=clamp(zoom*(e.deltaY>0?1.08:.92),.55,2.7)},{passive:true});

function onResize(){
  W=innerWidth;H=innerHeight;
  DPR=clamp(devicePixelRatio||1,1,mobile?CFG.mobileDprCap:CFG.dprCap);
  r.setPixelRatio(DPR);r.setSize(W,H);composer.setSize(W,H);
  cam.aspect=W/H;cam.updateProjectionMatrix();
  bg.material.uniforms.R.value.set(W*DPR,H*DPR);
  bloom.setSize(W,H);
}
addEventListener("resize",onResize);onResize();

/* 自适应性能：调 DPR + 后期强度（接近 0 卡顿的工程做法） */
let last=performance.now();
function adapt(dt){
  const fps=1000/dt; ema=ema*0.92+fps*0.08;
  if(ema<55 && quality>0.65) quality-=0.03;
  if(ema<45 && quality>0.50) quality-=0.06;
  if(ema>58 && quality<1.0) quality+=0.01;
  quality=clamp(quality,0.5,1);

  const target=clamp((mobile?1.45:1.85)*quality,0.9,mobile?CFG.mobileDprCap:CFG.dprCap);
  const cur=r.getPixelRatio();
  if(Math.abs(cur-target)>0.10){r.setPixelRatio(target);composer.setSize(W,H);bg.material.uniforms.R.value.set(W*target,H*target);}
  bloom.strength=1.0*(0.65+0.35*quality)+boom*0.9;
  bloom.radius=0.35+0.45*(1-quality);
  after.uniforms["damp"].value=0.86+0.10*quality;
  rgb.uniforms["amount"].value=0.0013*(1+boom*1.4)*(0.8+0.5*(1-quality));
  glitch.enabled = (quality>0.62) || boom>0.2;
  film.uniforms["nIntensity"].value=0.25+0.25*(1-quality);
  film.uniforms["sIntensity"].value=0.35+boom*0.35;
}

/* 粒子更新：时间分片（减少主线程波动） */
let frame=0;
function step(now){
  const dt=now-last;last=now;
  t+=dt*0.001*(1+(boom?2.2:0));
  boom&&=(boom*=0.88)<0.02?0:boom;

  const stride=Math.floor(2+6*(1-quality));
  const start=(frame++%stride);
  const pullBase=(md?0.030:0.012)*(1+boom*2.0), rotBase=0.070*(md?1.5:1.0)*(1+boom*1.0);
  const mx=px-panx,my=py-pany;

  for(let i=start;i<count;i+=stride){
    const ix=i*3,iv=i*2;
    let x=pos[ix],y=pos[ix+1],dx=x-mx*0.35,dy=y-my*0.35;
    let rr=dx*dx+dy*dy+1e-3,inv=1/Math.sqrt(rr);
    let vx=vel[iv],vy=vel[iv+1];
    const pull=pullBase*inv,rot=rotBase*inv;
    vx+=(-dx*pull - dy*rot); vy+=(-dy*pull + dx*rot);
    const h=hue[i];
    vx+=Math.sin((y*3+t*0.7)+h*9)*0.0006; vy+=Math.cos((x*3-t*0.6)+h*9)*0.0006;
    vx*=0.985; vy*=0.985;
    x+=vx; y+=vy;
    if(x>1.2)x=-1.2;if(x<-1.2)x=1.2;if(y>1.2)y=-1.2;if(y<-1.2)y=1.2;
    pos[ix]=x;pos[ix+1]=y;vel[iv]=vx;vel[iv+1]=vy;
  }
  geom.attributes.position.needsUpdate=true;

  bg.material.uniforms.T.value=t; bg.material.uniforms.M.value.set(px-panx,py-pany);
  bg.material.uniforms.Z.value=zoom; bg.material.uniforms.P.value.set(panx,pany); bg.material.uniforms.B.value=boom;
  mat.uniforms.T.value=t; mat.uniforms.M.value.set(px-panx,py-pany);
  mat.uniforms.Z.value=zoom; mat.uniforms.P.value.set(panx,pany); mat.uniforms.B.value=boom;

  adapt(dt);
  composer.render();

  if((frame&7)===0) S.textContent=`${mobile?"iOS/mobile":"desktop"} · fps~${ema.toFixed(0)} · q=${quality.toFixed(2)} · dpr=${r.getPixelRatio().toFixed(2)} · boom=${boom?boom.toFixed(2):0}`;
  requestAnimationFrame(step);
}
requestAnimationFrame(step);
</script>