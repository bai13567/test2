<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Ambient Gradient Field · Prev vs Current</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#050505}
canvas{position:fixed;inset:0;display:block}
#hud{position:fixed;left:12px;top:12px;right:12px;z-index:5;
font:12px ui-monospace,Menlo,Consolas,monospace;color:#fff;mix-blend-mode:screen;
background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.15);
border-radius:12px;padding:10px 12px;backdrop-filter:blur(10px)}
</style>
<canvas id="c"></canvas>
<div id="hud">DEBUG · 左=上一个背景 · 右=当前背景（每 3 秒切换，平滑过渡）</div>

<script>
(()=>{"use strict";
const C=document.getElementById("c"),ctx=C.getContext("2d",{alpha:false});
const clamp=(x,a,b)=>x<a?a:x>b?b:x;
const lerp=(a,b,t)=>a+(b-a)*t;
const mix3=(A,B,t)=>[lerp(A[0],B[0],t),lerp(A[1],B[1],t),lerp(A[2],B[2],t)];
const rgb=(c,a=1)=>`rgba(${c[0]|0},${c[1]|0},${c[2]|0},${a})`;

let W=0,H=0,DPR=1;
function resize(){
  DPR=Math.min(devicePixelRatio||1,2);
  W=innerWidth;H=innerHeight;
  C.width=(W*DPR)|0; C.height=(H*DPR)|0;
  C.style.width=W+"px"; C.style.height=H+"px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener("resize",resize,{passive:true}); resize();

// ===== 状态生成（确定性，便于复现）=====
function rand(seed){return ()=>((seed=(seed*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;}
function makeState(seed){
  const r=rand(seed>>>0);
  // 只做“环境场”参数：位置/色温/亮度层级（无形状、无纹理）
  return {
    gx:0.42+0.16*r(),   // radial center x
    gy:0.44+0.16*r(),   // radial center y
    warm:0.010+0.035*r(), // tiny warm lift
    deep:0.050+0.020*r(), // dark mix at edges (cashmere-ish)
    air: 0.10+0.08*r()    // vertical air layer
  };
}
function lerpState(a,b,t){
  return {
    gx:lerp(a.gx,b.gx,t),
    gy:lerp(a.gy,b.gy,t),
    warm:lerp(a.warm,b.warm,t),
    deep:lerp(a.deep,b.deep,t),
    air: lerp(a.air, b.air, t)
  };
}

// ===== 固定暖中性调色盘（调试版先锁死）=====
const P={top:[252,248,242], mid:[238,224,204], low:[214,182,140], ink:[28,22,18]};

// ===== 切换参数 =====
const STEP=3.0;   // 每 3 秒换一次
const FADE=0.7;   // 过渡时长（可调：0.5~1.0 都行）

// ===== 三态：prev / cur / next =====
let i=0;
let prev=makeState(0);
let cur =makeState(1);
let next=makeState(2);
let tSwitch=0;

// ease for fade (更像“状态变化”，不像动画)
const ease=x=>x*x*(3-2*x);

function drawField(state,x0,w){
  // base radial field
  const gx=x0 + w*state.gx;
  const gy=H*state.gy;
  const g=ctx.createRadialGradient(gx,gy, Math.min(w,H)*0.07, gx,gy, Math.max(w,H)*1.05);
  g.addColorStop(0, rgb(mix3(P.top,[255,255,255],state.warm)));
  g.addColorStop(0.48, rgb(P.mid));
  g.addColorStop(1, rgb(mix3(P.low,P.ink,state.deep)));
  ctx.fillStyle=g;
  ctx.fillRect(x0,0,w,H);

  // gentle vertical “air”
  ctx.save();
  ctx.globalCompositeOperation="soft-light";
  const air=ctx.createLinearGradient(0,0,0,H);
  air.addColorStop(0, `rgba(255,252,248,${0.12*state.air})`);
  air.addColorStop(0.55,"rgba(255,255,255,0)");
  air.addColorStop(1, `rgba(0,0,0,${0.06*state.air})`);
  ctx.fillStyle=air;
  ctx.fillRect(x0,0,w,H);
  ctx.restore();
}

let t0=performance.now();
function tick(now){
  requestAnimationFrame(tick);
  const t=(now-t0)*0.001;
  const half=W*0.5;

  // 状态更新：每 STEP 秒进入一次切换窗口
  const local=t-tSwitch;
  if(local>=STEP){
    // 完成一次“当前”确定：prev <- cur, cur <- next, next <- 新生成
    i++;
    prev=cur;
    cur=next;
    next=makeState(i+2);
    tSwitch=t;
  }

  // 右边：如果在 FADE 时间内，就从 cur 过渡到 next；否则保持 cur
  const k = clamp(local/FADE,0,1);
  const sRight = (k<1) ? lerpState(cur,next,ease(k)) : cur;

  // 绘制：左=prev（上一个完整背景）；右=当前（含过渡）
  drawField(prev, 0, half);
  drawField(sRight, half, half);

  // 分割线（仅调试）
  ctx.fillStyle="rgba(255,255,255,0.12)";
  ctx.fillRect(half-0.5,0,1,H);
}
requestAnimationFrame(tick);
})();
</script>