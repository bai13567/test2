<!doctype html>
<html lang="zh">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Cloudy Sky (Visible)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#eaf4ff}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
</style>
<canvas id="c"></canvas>

<script>
(()=> {
  const c=document.getElementById("c");
  const gl=c.getContext("webgl",{antialias:false,alpha:false});
  if(!gl) return;

  const V=`attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}`;
  const F=`precision highp float;
  uniform vec2 r; uniform float t;

  float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);}
  float noise(vec2 p){
    vec2 i=floor(p), f=fract(p); f=f*f*(3.-2.*f);
    float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
    return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
  }
  float fbm(vec2 p){
    float v=0., a=.6;
    for(int i=0;i<6;i++){ v+=a*noise(p); p=p*1.95+19.7; a*=.52; }
    return v;
  }
  // ridged noise：更像“棉花云团”
  float ridged(vec2 p){
    float s=0., a=.7;
    for(int i=0;i<5;i++){
      float n = noise(p);
      n = 1.0 - abs(2.0*n - 1.0);
      s += a*n;
      p = p*2.0 + 13.1;
      a *= 0.55;
    }
    return s;
  }
  float dither(vec2 p){return (hash(p+fract(t))*2.0-1.0)/255.0;}

  void main(){
    vec2 uv = gl_FragCoord.xy / r;
    vec2 p = uv*2.0 - 1.0;
    p.x *= r.x/r.y;

    // sky (稍微更有层次，避免太“平”)
    vec3 skyTop = vec3(0.70,0.86,1.00);
    vec3 skyMid = vec3(0.84,0.93,1.00);
    vec3 skyBot = vec3(0.95,0.98,1.00);
    float gy = smoothstep(-1.0,1.0,p.y);
    vec3 sky = mix(skyBot, skyMid, smoothstep(0.0,0.55,gy));
    sky = mix(sky,   skyTop, smoothstep(0.55,1.0,gy));
    sky += dither(gl_FragCoord.xy)*vec3(1.0);

    // 时间（稍微快一点，你现在太慢也像“没变化”）
    float tt = t*0.06;
    vec2 a = vec2( tt*0.60,  tt*0.28);
    vec2 b = vec2(-tt*0.40,  tt*0.22);
    vec2 c0= vec2( tt*0.18, -tt*0.35);

    // 云尺度：调大（你现在太“细小/淡”）
    vec2 q = p * 0.62;

    // 域扭曲：让云“形变”而非平移
    float w1 = fbm(q*1.1 + a);
    float w2 = fbm(q*1.9 + b);
    q += 0.33 * vec2(w1-0.5, w2-0.5);

    // 密度场：低频决定“哪里有云”，ridged 提供“云团”
    float low  = fbm(q*0.85 + a);
    float mid  = fbm(q*1.60 + b);
    float puff = ridged(q*1.20 + c0);   // 关键：让云变“棉”

    // 对比增强：让云从雾变团（但仍是白云）
    float dens = low*0.55 + mid*0.20 + puff*0.45;
    dens = clamp(dens,0.0,1.0);
    dens = smoothstep(0.30, 0.95, dens); // 提升整体对比

    // 覆盖率控制（你现在是“没云”，所以阈值必须更低）
    float cloud = smoothstep(0.40, 0.65, dens); // <<<<<< 核心：更容易出云
    cloud = pow(cloud, 1.25);

    // 边缘纤维：只在边缘起作用
    float fine = fbm(q*4.8 + b);
    float rim = smoothstep(0.12,0.55,cloud) * (1.0 - smoothstep(0.55,0.95,cloud));
    cloud *= 0.90 + 0.18*fine*rim;

    // 云内部厚薄明暗（非常轻，绝不会变乌云）
    float shade = 0.96 + 0.06*(fine-0.5);
    shade = clamp(shade, 0.92, 1.03);

    vec3 cloudCol = vec3(1.0,0.997,0.990) * shade;

    // 银边高光：让云更“蓬”
    float silver = smoothstep(0.70, 0.98, fine) * rim;
    cloudCol = mix(cloudCol, vec3(1.0), 0.18*silver);

    // 合成：云更“实”（你现在的图云太淡）
    vec3 col = mix(sky, cloudCol, clamp(cloud*1.55, 0.0, 1.0));

    col = clamp(col,0.0,1.0);
    col = pow(col, vec3(0.99));
    gl_FragColor = vec4(col,1.0);
  }`;

  function sh(type,src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  }
  const P=gl.createProgram();
  gl.attachShader(P,sh(gl.VERTEX_SHADER,V));
  gl.attachShader(P,sh(gl.FRAGMENT_SHADER,F));
  gl.linkProgram(P);
  if(!gl.getProgramParameter(P,gl.LINK_STATUS)) throw gl.getProgramInfoLog(P);
  gl.useProgram(P);

  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]),gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(P,"p");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  const ur=gl.getUniformLocation(P,"r");
  const ut=gl.getUniformLocation(P,"t");

  function resize(){
    const d=Math.min(2,devicePixelRatio||1);
    const vw=visualViewport?visualViewport.width:innerWidth;
    const vh=visualViewport?visualViewport.height:innerHeight;
    c.width=Math.max(1,Math.floor(vw*d));
    c.height=Math.max(1,Math.floor(vh*d));
    gl.viewport(0,0,c.width,c.height);
    gl.uniform2f(ur,c.width,c.height);
  }
  addEventListener("resize",resize,{passive:true});
  visualViewport && visualViewport.addEventListener("resize",resize,{passive:true});
  resize();

  let t0=performance.now(), paused=false;
  document.addEventListener("visibilitychange",()=>paused=document.hidden,{passive:true});

  (function loop(now){
    if(!paused){
      gl.uniform1f(ut,(now-t0)/1000);
      gl.drawArrays(gl.TRIANGLES,0,6);
    }
    requestAnimationFrame(loop);
  })(t0);
})();
</script>
</html>