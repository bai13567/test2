<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Warm Healing AAA Background</title>
<style>
html,body{margin:0;height:100%;background:#07060a;overflow:hidden;font:12px ui-monospace,Menlo,Consolas,monospace}
#c{position:fixed;inset:0;display:block}
#ui{position:fixed;left:12px;right:12px;top:12px;z-index:9;display:flex;gap:10px;align-items:center;pointer-events:none;padding-top:env(safe-area-inset-top)}
#pill{flex:1;min-width:0;padding:10px 12px;border-radius:14px;border:1px solid #ffd3a855;
background:linear-gradient(90deg,#ffbf6a22,#ff7aa822,#7ad7ff18);
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset,0 16px 44px #000c;color:#ffe9d6;mix-blend-mode:screen;
text-shadow:0 0 18px #ffbf6a66,0 0 30px #ff7aa844;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#pill b{color:#fff}
#btn{pointer-events:auto;padding:10px 14px;border-radius:14px;border:1px solid #fff2;background:#0006;color:#fff;backdrop-filter:blur(12px);
box-shadow:0 0 0 1px #fff1 inset}
#btn:active{transform:translateY(1px)}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99;color:#ffd1d1;background:#2a0000cc;border:1px solid #ff6a6a55;
border-radius:12px;padding:10px 12px;display:none;white-space:pre-wrap}
body:before{content:"";position:fixed;inset:-60px;pointer-events:none;background:
repeating-linear-gradient(0deg,rgba(255,255,255,.04),rgba(255,255,255,.04) 1px,transparent 2px,transparent 7px);
mix-blend-mode:overlay;opacity:.14;animation:scan 12s linear infinite}
@keyframes scan{to{transform:translateY(60px)}}
</style>

<canvas id="c"></canvas>
<div id="ui">
  <div id="pill"><b>WARM HEALING</b> · <span id="s">loading…</span></div>
  <button id="btn">切换</button>
</div>
<div id="err"></div>

<script>
(()=>{"use strict";
const canvas=document.getElementById("c"),S=document.getElementById("s"),BTN=document.getElementById("btn"),ERR=document.getElementById("err");
const mobile=matchMedia("(pointer:coarse)").matches||innerWidth<760;
const clamp=(x,a,b)=>x<a?a:x>b?b:x, lerp=(a,b,t)=>a+(b-a)*t;

let gl=canvas.getContext("webgl",{alpha:false,antialias:false,depth:false,stencil:false,premultipliedAlpha:false})
     ||canvas.getContext("experimental-webgl");
if(!gl){ERR.style.display="block";ERR.textContent="WebGL unavailable in this browser.";return;}

const VSH=`attribute vec2 p;varying vec2 v;void main(){v=p*0.5+0.5;gl_Position=vec4(p,0.,1.);} `;
const FSH=`precision highp float;varying vec2 v;
uniform vec2 R;uniform float T;uniform vec4 A;uniform vec4 B;uniform vec4 C;uniform vec3 H;uniform float Q;

// noise / fbm
float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);}
float noise(vec2 p){
  vec2 i=floor(p),f=fract(p);vec2 u=f*f*(3.0-2.0*f);
  float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
  return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);
}
float fbm(vec2 p){
  float f=0.,a=.5; mat2 m=mat2(1.6,1.2,-1.2,1.6);
  for(int i=0;i<6;i++){f+=a*noise(p);p=m*p;a*=.5;}
  return f;
}
vec3 hsv2rgb(vec3 c){
  vec4 K=vec4(1.,2./3.,1./3.,3.);
  vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);
  return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);
}
vec3 warmPalette(float x){
  // H.x ~ base warm hue; H.y ~ secondary warm; H.z ~ soft teal accent (kept small in mix)
  vec3 c1=hsv2rgb(vec3(H.x, 0.85, 1.0));
  vec3 c2=hsv2rgb(vec3(H.y, 0.80, 1.0));
  vec3 c3=hsv2rgb(vec3(H.z, 0.55, 1.0));
  vec3 col=mix(c1,c2,smoothstep(0.10,0.90,x));
  col=mix(col,c3,smoothstep(0.78,0.98,x)*0.18); // teal only as highlight seasoning
  return col;
}
void main(){
  vec2 uv=(gl_FragCoord.xy-0.5*R)/R.y;

  float t=T*(0.55+0.70*A.w);
  vec2 cam=vec2(sin(t*0.06),cos(t*0.05))*0.12*(0.30+0.70*B.w);
  uv += cam;

  // gentle domain warp (healing, not chaotic)
  vec2 p=uv;
  float w1=fbm(p*(1.2+2.0*A.x)+vec2(t*0.09,-t*0.07));
  float w2=fbm(p*(1.8+2.6*A.y)+vec2(-t*0.05,t*0.10));
  p += vec2(w1-w2,w2-w1)*(0.12+0.42*A.z);

  float r=length(p)+1e-4, ang=atan(p.y,p.x);

  // structures tuned for “soft, expensive”
  float veins = fbm(p*(2.8+5.0*C.x) + vec2(t*0.10,-t*0.08));
  float mist  = fbm(p*(1.1+2.8*C.y) - vec2(t*0.04,t*0.03));
  float bands = sin((r*(6.5+10.0*B.x)-t*(1.0+1.2*B.y)) + ang*(2.0+4.0*B.z));
  float core  = exp(-r*(1.4+2.2*C.z));

  float field = 0.55*veins + 0.36*mist + 0.18*(bands*0.5+0.5) + 0.42*core;
  field = smoothstep(0.02,0.98, clamp(field,0.,1.));

  vec3 col = warmPalette(field);

  // warm glow + soft bloom
  float glow = pow(field,2.0)*(0.30+0.90*B.w) + core*(0.55+0.65*A.w);
  col += col*glow*(0.55+0.75*A.y);

  // filmic curve
  col = col/(1.0+col);
  col = pow(col, vec3(0.95+0.10*C.y)); // warm-friendly gamma

  // vignette
  float vig = smoothstep(1.20,0.20,length(uv));
  col *= (0.78+0.45*vig);

  // subtle grain (luma-ish)
  float g = hash(gl_FragCoord.xy + vec2(T*55.0, T*33.0));
  col += (g-0.5) * (0.012+0.012*(1.0-vig)) * (0.35+0.65*C.x);

  // adaptive Q: small contrast bump if downscaled
  col = mix(col, col*1.04, clamp((1.0-Q)*1.0,0.,0.5));

  gl_FragColor=vec4(col,1.0);
}`;

function compile(type,src){
  const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)||"shader compile failed");
  return s;
}
let prog,loc={},buf;
function build(){
  try{
    const vs=compile(gl.VERTEX_SHADER,VSH), fs=compile(gl.FRAGMENT_SHADER,FSH);
    prog=gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog)||"program link failed");
    gl.useProgram(prog);
    buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),gl.STATIC_DRAW);
    const pLoc=gl.getAttribLocation(prog,"p"); gl.enableVertexAttribArray(pLoc);
    gl.vertexAttribPointer(pLoc,2,gl.FLOAT,false,0,0);
    ["R","T","A","B","C","H","Q"].forEach(k=>loc[k]=gl.getUniformLocation(prog,k));
    ERR.style.display="none";
  }catch(e){ERR.style.display="block";ERR.textContent=String(e);}
}
build();

// ---- Offscreen preview FBO for scoring (tiny, fast) ----
const PRE=64;
const fbo=gl.createFramebuffer();
const tex=gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D,tex);
gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,PRE,PRE,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
gl.bindFramebuffer(gl.FRAMEBUFFER,fbo);
gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0);
gl.bindFramebuffer(gl.FRAMEBUFFER,null);
const pix=new Uint8Array(PRE*PRE*4);

// ---- Controlled warm random generator ----
// hues in 0..1; warm base around 25°..55°, secondary around 10°..30°, teal accent around 175°..200° tiny
const rnd=()=>Math.random();
function genParams(){
  const hBase = lerp(25/360, 55/360, Math.pow(rnd(),0.7));
  const h2    = clamp(hBase - lerp(6/360,18/360,rnd()) + (rnd()<0.35? lerp(4/360,10/360,rnd()):0), 0, 1);
  const hTeal = lerp(175/360, 200/360, rnd());
  const A=[rnd(),rnd(), 0.18+0.52*rnd(), 0.62+0.35*rnd()];
  const B=[0.22+0.60*rnd(), 0.25+0.55*rnd(), 0.10+0.65*rnd(), 0.55+0.45*rnd()];
  const C=[0.28+0.62*rnd(), 0.22+0.62*rnd(), 0.24+0.70*rnd(), 0]; // C.w unused in this shader, keep 0
  const H=[hBase,h2,hTeal];
  return {A,B,C,H};
}

// ---- Aesthetic scoring (高级但仍然便宜) ----
function rgb2hsv(r,g,b){
  const mx=Math.max(r,g,b), mn=Math.min(r,g,b), d=mx-mn;
  let h=0;
  if(d!==0){
    if(mx===r) h=((g-b)/d)%6;
    else if(mx===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h/=6; if(h<0) h+=1;
  }
  const s=mx===0?0:d/mx, v=mx;
  return [h,s,v];
}
function scorePixels(){
  let n=PRE*PRE, lumSum=0, lum2=0, satSum=0, warm=0, purple=0, dark=0, hot=0, teal=0;
  let grad=0, hiFreq=0;
  // first pass: stats
  for(let y=0;y<PRE;y++){
    for(let x=0;x<PRE;x++){
      const i=(y*PRE+x)*4;
      const r=pix[i]/255, g=pix[i+1]/255, b=pix[i+2]/255;
      const lum=0.2126*r+0.7152*g+0.0722*b;
      lumSum+=lum; lum2+=lum*lum;
      const [h,s,v]=rgb2hsv(r,g,b);
      satSum+=s;

      // warm band: ~15°..70° plus some peach: ~0°..15°
      if((h>=0 && h<15/360) || (h>=15/360 && h<=70/360)) warm+=1;

      // purple/magenta (ugly for “治愈暖”): ~255°..330° (0.708..0.916)
      if(h>=255/360 && h<=330/360) purple+=1;

      // teal accent (allowed but should be small): ~165°..210°
      if(h>=165/360 && h<=210/360) teal+=1;

      if(lum<0.10) dark+=1;
      if(lum>0.92 && s>0.55) hot+=1;

      // gradient energy (texture finesse): use neighbor diffs
      if(x>0){
        const j=i-4;
        const dr=r-pix[j]/255, dg=g-pix[j+1]/255, db=b-pix[j+2]/255;
        const dL=Math.abs(0.2126*dr+0.7152*dg+0.0722*db);
        grad+=dL;
        if(dL>0.20) hiFreq+=1;
      }
      if(y>0){
        const j=i-PRE*4;
        const dr=r-pix[j]/255, dg=g-pix[j+1]/255, db=b-pix[j+2]/255;
        const dL=Math.abs(0.2126*dr+0.7152*dg+0.0722*db);
        grad+=dL;
        if(dL>0.20) hiFreq+=1;
      }
    }
  }
  const lumMean=lumSum/n;
  const lumVar=Math.max(0, lum2/n - lumMean*lumMean);
  const lumStd=Math.sqrt(lumVar);
  const satMean=satSum/n;

  const warmP=warm/n, purpleP=purple/n, darkP=dark/n, hotP=hot/n, tealP=teal/n;
  const gradMean=grad/(n*2); // rough normalize
  const hiFreqP=hiFreq/(n*2);

  // --- scoring (0..100) ---
  // goals: warm dominance, medium luminance, medium contrast, medium saturation, low purple, low black blocks, low harsh high-freq
  let score=0;

  // Warm dominance
  score += 42 * clamp((warmP-0.55)/0.35, 0, 1);

  // Luminance target around 0.55 (soft warm daylight)
  score += 18 * Math.exp(-Math.pow((lumMean-0.55)/0.18,2));

  // Contrast target (std) around 0.20 (not flat, not harsh)
  score += 10 * Math.exp(-Math.pow((lumStd-0.20)/0.10,2));

  // Saturation target around 0.45 (healing but not dull)
  score += 10 * Math.exp(-Math.pow((satMean-0.45)/0.18,2));

  // Penalize purple/magenta heavily
  score -= 55 * clamp((purpleP-0.02)/0.06, 0, 1);

  // Penalize too much darkness
  score -= 25 * clamp((darkP-0.08)/0.18, 0, 1);

  // Penalize blown neon hot spots (cheap look)
  score -= 18 * clamp((hotP-0.03)/0.10, 0, 1);

  // Teal should be seasoning, not a flood
  score -= 12 * clamp((tealP-0.16)/0.20, 0, 1);

  // Texture finesse: reward some gradient but punish harsh hi-freq noise
  score += 8 * clamp((gradMean-0.03)/0.05, 0, 1);
  score -= 16 * clamp((hiFreqP-0.01)/0.06, 0, 1);

  return clamp(score, 0, 100);
}

function renderPreview(params){
  gl.bindFramebuffer(gl.FRAMEBUFFER,fbo);
  gl.viewport(0,0,PRE,PRE);
  gl.useProgram(prog);
  gl.uniform2f(loc.R, PRE, PRE);
  gl.uniform1f(loc.T, 1.37); // fixed time snapshot for evaluation
  gl.uniform4f(loc.A, params.A[0],params.A[1],params.A[2],params.A[3]);
  gl.uniform4f(loc.B, params.B[0],params.B[1],params.B[2],params.B[3]);
  gl.uniform4f(loc.C, params.C[0],params.C[1],params.C[2],params.C[3]);
  gl.uniform3f(loc.H, params.H[0],params.H[1],params.H[2]);
  gl.uniform1f(loc.Q, 1.0);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
  gl.readPixels(0,0,PRE,PRE,gl.RGBA,gl.UNSIGNED_BYTE,pix);
  gl.bindFramebuffer(gl.FRAMEBUFFER,null);
}

function findGoodCandidate(maxTry=10, threshold=72){
  let best=null, bestScore=-1;
  for(let i=0;i<maxTry;i++){
    const p=genParams();
    renderPreview(p);
    const sc=scorePixels();
    if(sc>bestScore){bestScore=sc; best=p; best._score=sc;}
    if(sc>=threshold) return best; // early accept
  }
  return best; // fallback best-effort
}

// ---- Runtime rendering ----
let W=0,H=0,dpr=1,scale=1,ema=60;
let cur=findGoodCandidate(8,74), next=null, t0=performance.now(), last=performance.now();

// adaptive targets
const target = mobile ? 60 : 90;

// main resize
function resize(){
  dpr=clamp(devicePixelRatio||1,1,mobile?2.0:2.6);
  W=innerWidth; H=innerHeight;
  canvas.width=Math.floor(W*dpr*scale);
  canvas.height=Math.floor(H*dpr*scale);
  canvas.style.width=W+"px"; canvas.style.height=H+"px";
  gl.viewport(0,0,canvas.width,canvas.height);
}
addEventListener("resize",resize,{passive:true}); resize();

function apply(p){cur=p; t0=performance.now();}

function scheduleNext(){
  // “立刻开始算下一套”：分片做，避免卡顿
  let tries=0, best=null, bestScore=-1;
  const step=()=>{
    // 每次只做少量尝试，iOS 更稳
    const batch=2;
    for(let k=0;k<batch;k++){
      const p=genParams();
      renderPreview(p);
      const sc=scorePixels();
      tries++; if(sc>bestScore){bestScore=sc; best=p; best._score=sc;}
      if(sc>=76 || tries>=14){ next=best; return; }
    }
    setTimeout(step,0);
  };
  next=null; step();
}

function switchNow(){
  if(next){apply(next); next=null; scheduleNext();}
  else { // 若还没算完，先用当前再启动一次
    apply(findGoodCandidate(6,74));
    scheduleNext();
  }
  // reset minute timer
  clearInterval(auto); auto=setInterval(()=>switchNow(),60*1000);
}

BTN.onclick=switchNow;

// auto switch every minute
let auto=setInterval(()=>switchNow(),60*1000);

// kick off precompute immediately
scheduleNext();

function draw(now){
  requestAnimationFrame(draw);
  const dt=now-last; last=now;
  const fps=1000/(dt||16.7); ema=ema*0.92+fps*0.08;

  // adaptive scale (prefer high-res “3A”, but keep smooth)
  if(ema<target*0.92) scale=clamp(scale*0.985, 0.78, 1.0);
  if(ema>target*1.03) scale=clamp(scale*1.003, 0.78, 1.0);
  if((now|0)%250<dt && Math.abs(canvas.width-(W*dpr*scale))>2) resize();

  gl.useProgram(prog);
  gl.uniform2f(loc.R, canvas.width, canvas.height);
  gl.uniform1f(loc.T, (now-t0)*0.001);
  gl.uniform4f(loc.A, cur.A[0],cur.A[1],cur.A[2],cur.A[3]);
  gl.uniform4f(loc.B, cur.B[0],cur.B[1],cur.B[2],cur.B[3]);
  gl.uniform4f(loc.C, cur.C[0],cur.C[1],cur.C[2],cur.C[3]);
  gl.uniform3f(loc.H, cur.H[0],cur.H[1],cur.H[2]);
  gl.uniform1f(loc.Q, scale);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

  if(((now/250)|0)%2===0){
    const sc=cur._score!=null?cur._score.toFixed(0):"--";
    const nx=next&&next._score!=null?next._score.toFixed(0):"…";
    S.textContent=`warm-healing · score=${sc} · next=${nx} · fps~${ema.toFixed(0)} · ${canvas.width}×${canvas.height} · auto=60s`;
  }
}
requestAnimationFrame(draw);
})();
</script>