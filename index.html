<!doctype html>
<html lang="zh">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>White Clouds (High Contrast)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#eaf3ff}
  canvas{position:fixed;inset:0;width:100%;height:100%;display:block;touch-action:none}
</style>
<canvas id="c"></canvas>

<script>
(()=> {
  const c=document.getElementById("c");
  const gl=c.getContext("webgl",{antialias:false,alpha:false}) || c.getContext("experimental-webgl",{antialias:false,alpha:false});
  if(!gl){
    const g=c.getContext("2d"); if(!g) return;
    g.fillStyle="#000"; g.font="16px system-ui";
    g.fillText("WebGL not supported",20,30);
    return;
  }

  const V=`attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}`;

  // 重点：更强的厚度、阴影、银边、局部对比
  const F=`precision highp float;
uniform vec2 r; uniform float t;

float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }
float noise(vec2 p){
  vec2 i=floor(p), f=fract(p); f=f*f*(3.-2.*f);
  float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
  return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
}
float fbm(vec2 p){
  float v=0., a=.55;
  for(int i=0;i<6;i++){ v+=a*noise(p); p=p*2.02+17.3; a*=.5; }
  return v;
}
vec2 flow(vec2 p){
  float e=.08;
  float n1=fbm(p+vec2(0,e));
  float n2=fbm(p-vec2(0,e));
  float n3=fbm(p+vec2(e,0));
  float n4=fbm(p-vec2(e,0));
  return vec2(n1-n2, n4-n3);
}

void main(){
  vec2 uv = gl_FragCoord.xy / r;
  vec2 p = uv*2.0 - 1.0;
  p.x *= r.x / r.y;

  // 时间：慢速大气流动
  float tt = t*0.03;
  vec2 drift = vec2(tt*1.05, tt*0.62);

  // 下厚上薄
  float h = clamp((p.y+1.0)*0.5, 0.0, 1.0);
  float layer = mix(1.22, 0.80, h);
  vec2 q = p*0.98*layer;

  // 卷动扭曲，避免贴图平移感
  q += 0.22*flow(q*1.2 + drift*0.8) + 0.09*flow(q*2.0 - drift*1.1);

  // 三频：形体/细节/纤维
  float shape  = fbm(q*0.72 + drift*0.55);
  float detail = fbm(q*1.75 - drift*0.95);
  float wisps  = fbm(q*3.60 + drift*1.35);

  // ⭐ 云量更大（cover 更低 = 更容易有云）
  float cover = mix(0.46, 0.56, 1.0-h);
  float base = shape - cover;

  // mask 与边缘带
  float m    = smoothstep(-0.12, 0.22, base);
  float edge = smoothstep(0.22, -0.07, abs(base)); // 边缘附近≈1

  // ⭐ 密度更厚：内部 + 边缘纤维
  float dens = m * (0.58 + 0.42*detail);
  dens += edge * 0.30 * (wisps-0.5);
  dens = clamp(dens, 0.0, 1.0);
  dens = clamp(dens*1.35, 0.0, 1.0); // ⭐ 关键：厚度上去

  // 光照：来自左上
  vec2 L2 = normalize(vec2(-0.45, 0.90));

  // 用密度场近似法线（梯度）
  float e=0.0035;
  float s1=fbm((q+vec2(e,0))*0.9 + drift*0.55);
  float s2=fbm((q-vec2(e,0))*0.9 + drift*0.55);
  float s3=fbm((q+vec2(0,e))*0.9 + drift*0.55);
  float s4=fbm((q-vec2(0,e))*0.9 + drift*0.55);
  float dx = s1 - s2;
  float dy = s3 - s4;
  vec3 N = normalize(vec3(-dx*2.5, -dy*2.5, 1.0));

  // 漫反射 + 轻微顶光偏置（更立体）
  float ndl = clamp(dot(N, vec3(L2, 0.65)), 0.0, 1.0);
  float topLight = pow(clamp(N.y*0.5+0.5, 0.0, 1.0), 1.2);
  float light = clamp(0.18 + 0.70*ndl + 0.12*topLight, 0.0, 1.0);

  // ⭐ 厚度阴影：越厚越暗（内部体积感）
  float thick = dens*dens;
  float shadow = exp(-3.0*thick);           // 厚处强压暗
  float inner = mix(0.55, 1.0, shadow);     // 0.55~1.0

  // ⭐ 银边：边缘更亮（薄云逆光）
  float rim = pow(1.0 - clamp(dot(N, vec3(0,0,1)), 0.0, 1.0), 2.2);
  float silver = rim * edge * (0.35 + 0.65*ndl);

  // 天空：稍压暗，拉开云对比
  vec3 skyTop = vec3(0.77, 0.88, 1.00);
  vec3 skyBot = vec3(0.90, 0.945, 1.00);
  vec3 sky = mix(skyBot, skyTop, smoothstep(-1.0, 1.0, p.y));
  sky *= 0.985; // 很轻的整体压暗

  // 云颜色：亮部暖白，阴影冷蓝灰（但别脏）
  vec3 warm = vec3(1.00, 0.995, 0.985);
  vec3 cool = vec3(0.70, 0.80, 0.96);
  vec3 cloudBase = mix(cool, warm, light);
  cloudBase *= inner; // 体积阴影

  // ⭐ 云遮挡（alpha）更强：更明显、更立体
  float alpha = clamp(dens*1.75, 0.0, 1.0);

  // 透射：薄处透更多天空（边缘更柔）
  float trans = exp(-2.6*thick);
  float mixAmt = alpha*(0.80 + 0.20*(1.0-trans));

  vec3 col = mix(sky, cloudBase, mixAmt);

  // 银边提亮（更明显但控制强度）
  col = mix(col, vec3(1.0), 0.30*silver);

  // ⭐ 局部对比增强（不会灰）：S-curve
  col = clamp(col, 0.0, 1.0);
  col = col*col*(3.0-2.0*col);     // smoothstep 曲线提升对比
  col = pow(col, vec3(0.95));      // 轻微提亮白云

  gl_FragColor = vec4(clamp(col,0.0,1.0), 1.0);
}`;

  function sh(type,src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s);
    return s;
  }
  const P=gl.createProgram();
  gl.attachShader(P,sh(gl.VERTEX_SHADER,V));
  gl.attachShader(P,sh(gl.FRAGMENT_SHADER,F));
  gl.linkProgram(P);
  if(!gl.getProgramParameter(P,gl.LINK_STATUS)) throw gl.getProgramInfoLog(P);
  gl.useProgram(P);

  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
  ]),gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(P,"p");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  const ur=gl.getUniformLocation(P,"r");
  const ut=gl.getUniformLocation(P,"t");

  function resize(){
    const d=Math.min(2,devicePixelRatio||1);
    const vw=visualViewport?visualViewport.width:innerWidth;
    const vh=visualViewport?visualViewport.height:innerHeight;
    c.width=Math.max(1,Math.floor(vw*d));
    c.height=Math.max(1,Math.floor(vh*d));
    gl.viewport(0,0,c.width,c.height);
    gl.uniform2f(ur,c.width,c.height);
  }
  addEventListener("resize",resize,{passive:true});
  visualViewport && visualViewport.addEventListener("resize",resize,{passive:true});
  resize();

  let t0=performance.now(), paused=false;
  document.addEventListener("visibilitychange",()=>paused=document.hidden,{passive:true});

  (function loop(now){
    if(!paused){
      gl.uniform1f(ut,(now-t0)/1000);
      gl.drawArrays(gl.TRIANGLES,0,6);
    }
    requestAnimationFrame(loop);
  })(t0);
})();
</script>
</html>