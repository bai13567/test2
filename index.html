<!doctype html>
<html lang="zh">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Soft White Clouds</title>

<style>
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  background:#eaf4ff;
}
canvas{
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  display:block;
}
</style>

<canvas id="c"></canvas>

<script>
(()=>{

const c = document.getElementById("c");
const gl = c.getContext("webgl",{antialias:false,alpha:false});
if(!gl) return;

const V = `attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}`;

const F = `precision highp float;
uniform vec2 r;
uniform float t;

/* noise */
float h(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float n(vec2 p){
  vec2 i=floor(p),f=fract(p);
  f=f*f*(3.-2.*f);
  return mix(
    mix(h(i),h(i+vec2(1,0)),f.x),
    mix(h(i+vec2(0,1)),h(i+vec2(1,1)),f.x),
    f.y
  );
}
float fbm(vec2 p){
  float v=0.,a=.6;
  for(int i=0;i<5;i++){
    v+=a*n(p);
    p=p*1.9+17.7;
    a*=.55;
  }
  return v;
}

void main(){
  vec2 uv = gl_FragCoord.xy / r;
  vec2 p = uv*2.0-1.0;
  p.x *= r.x/r.y;

  /* sky gradient */
  vec3 skyTop = vec3(0.80,0.90,1.00);
  vec3 skyBot = vec3(0.94,0.97,1.00);
  vec3 sky = mix(skyBot, skyTop, smoothstep(-1.0,1.0,p.y));

  /* slow evolving cloud field (not sliding) */
  float t1 = t*0.04;
  float base = fbm(p*0.9 + vec2(0.0,t1));
  float shape = fbm(p*1.6 + vec2(t1*0.3,-t1*0.2));
  float detail = fbm(p*3.2 - vec2(t1*0.6,0.0));

  float density = base*0.6 + shape*0.3 + detail*0.1;

  /* critical: low coverage */
  float cloud = smoothstep(0.58, 0.72, density);

  /* cloud thickness */
  float soft = fbm(p*4.5 + t1);
  cloud *= smoothstep(0.3,0.7,soft);

  /* cloud color */
  float light = 0.95 + 0.05*detail;
  vec3 cloudCol = vec3(1.0,0.995,0.985) * light;

  /* edge softness */
  cloud = smoothstep(0.0,1.0,cloud);
  cloud = pow(cloud,1.3);

  /* composite */
  vec3 col = mix(sky, cloudCol, cloud);

  gl_FragColor = vec4(col,1.0);
}
`;

function sh(t,s){
  const x=gl.createShader(t);
  gl.shaderSource(x,s);
  gl.compileShader(x);
  return x;
}

const P=gl.createProgram();
gl.attachShader(P,sh(gl.VERTEX_SHADER,V));
gl.attachShader(P,sh(gl.FRAGMENT_SHADER,F));
gl.linkProgram(P);
gl.useProgram(P);

const buf=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,buf);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
  -1,-1, 1,-1, -1,1,
  -1,1, 1,-1, 1,1
]),gl.STATIC_DRAW);

const loc=gl.getAttribLocation(P,"p");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

const ur=gl.getUniformLocation(P,"r");
const ut=gl.getUniformLocation(P,"t");

function resize(){
  const d=Math.min(2,devicePixelRatio||1);
  const vw=visualViewport?visualViewport.width:innerWidth;
  const vh=visualViewport?visualViewport.height:innerHeight;
  c.width=vw*d;
  c.height=vh*d;
  gl.viewport(0,0,c.width,c.height);
  gl.uniform2f(ur,c.width,c.height);
}
addEventListener("resize",resize,{passive:true});
visualViewport&&visualViewport.addEventListener("resize",resize,{passive:true});
resize();

let t0=performance.now();
(function loop(now){
  gl.uniform1f(ut,(now-t0)/1000);
  gl.drawArrays(gl.TRIANGLES,0,6);
  requestAnimationFrame(loop);
})(t0);

})();
</script>
</html>