<!doctype html><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Clear Water · Cloud Reflection</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;font:12px ui-monospace,Menlo,Consolas,monospace}
canvas{position:fixed;inset:0;display:block}
#ui{position:fixed;left:12px;right:12px;top:12px;z-index:9;display:flex;gap:10px;align-items:center;pointer-events:none;padding-top:env(safe-area-inset-top)}
#pill{flex:1;min-width:0;padding:10px 12px;border-radius:14px;border:1px solid #ffffff2a;
background:linear-gradient(90deg,#ffffff14,#7ad7ff14,#ffd6a814);
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset,0 16px 44px #000a;color:#eef7ff;mix-blend-mode:screen;
text-shadow:0 0 18px #7ad7ff44,0 0 22px #ffd6a844;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
#pill b{color:#fff}
#btn{pointer-events:auto;padding:10px 14px;border-radius:14px;border:1px solid #fff2;background:#0006;color:#fff;
backdrop-filter:blur(12px);box-shadow:0 0 0 1px #fff1 inset}
#btn:active{transform:translateY(1px)}
#err{position:fixed;left:12px;right:12px;bottom:12px;z-index:99;display:none;
background:#2a0000cc;border:1px solid #ff6a6a55;color:#ffd1d1;border-radius:12px;padding:10px 12px;white-space:pre-wrap}
</style>

<canvas id="c"></canvas>
<div id="ui">
  <div id="pill"><b>CLEAR WATER</b> · <span id="s">loading…</span></div>
  <button id="btn">切换</button>
</div>
<div id="err"></div>

<script>
(()=>{"use strict";
const C=document.getElementById("c");
const ctx=C.getContext("2d",{alpha:false, willReadFrequently:false});
const S=document.getElementById("s"), BTN=document.getElementById("btn"), ERR=document.getElementById("err");
const mobile=matchMedia("(pointer:coarse)").matches||innerWidth<760;
const clamp=(x,a,b)=>x<a?a:x>b?b:x;
const lerp=(a,b,t)=>a+(b-a)*t;
const smoothstep=(a,b,x)=>{x=clamp((x-a)/(b-a),0,1);return x*x*(3-2*x);};
const mix3=(A,B,t)=>[lerp(A[0],B[0],t),lerp(A[1],B[1],t),lerp(A[2],B[2],t)];
const dot=(ax,ay,az,bx,by,bz)=>ax*bx+ay*by+az*bz;

function showErr(e){ERR.style.display="block";ERR.textContent=String(e&&(e.stack||e.message)||e);}

try{
let W=0,H=0,DPR=1;
function resize(){
  DPR=clamp(devicePixelRatio||1,1,2);
  W=innerWidth; H=innerHeight;
  C.width=Math.max(2,Math.floor(W*DPR));
  C.height=Math.max(2,Math.floor(H*DPR));
  C.style.width=W+"px"; C.style.height=H+"px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
  alloc();
}
addEventListener("resize",resize,{passive:true});

// ---- RNG ----
function makeRng(seed){let s=seed>>>0;return ()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;}

// ---- Fast 2D value-noise + fbm (for clouds & subtle depth) ----
function hash2(ix,iy,seed){
  let x=(ix*374761393+iy*668265263)^(seed*1442695041);
  x=(x^(x>>>13))*1274126177;
  return ((x^(x>>>16))>>>0)/4294967295;
}
function vnoise2(x,y,seed){
  const ix=x|0, iy=y|0;
  const fx=x-ix, fy=y-iy;
  const a=hash2(ix,iy,seed), b=hash2(ix+1,iy,seed), c=hash2(ix,iy+1,seed), d=hash2(ix+1,iy+1,seed);
  const ux=fx*fx*(3-2*fx), uy=fy*fy*(3-2*fy);
  const ab=a+(b-a)*ux, cd=c+(d-c)*ux;
  return ab+(cd-ab)*uy;
}
function fbm(x,y,seed){
  let f=0, amp=0.55, freq=1;
  f += amp*vnoise2(x*freq,y*freq,seed); freq*=2; amp*=0.5;
  f += amp*vnoise2(x*freq,y*freq,seed+101); freq*=2; amp*=0.5;
  f += amp*vnoise2(x*freq,y*freq,seed+202);
  return f;
}

// ---- Offscreen low-res renderer (keeps iOS smooth) ----
const off=document.createElement("canvas");
const octx=off.getContext("2d",{alpha:false, willReadFrequently:true});
let OW=0,OH=0,img=null,data=null;
let q=mobile?0.42:0.48;

function alloc(){
  OW=Math.max(220, Math.min(620, (W*q)|0));
  OH=Math.max(360, Math.min(980, (H*q)|0));
  off.width=OW; off.height=OH;
  img=octx.createImageData(OW,OH);
  data=img.data;
}

// ---- Scene params (water+sky+cloud) ----
let seedBase=123456789, scene=null;
function newScene(){
  seedBase=(seedBase*1664525+1013904223)>>>0;
  const rnd=makeRng(seedBase);

  // sky palette (clear noon / warm evening mix, no purple)
  const skyTop = [120+40*rnd(), 185+35*rnd(), 235+15*rnd()];     // blue
  const skyHzn = [205+35*rnd(), 225+25*rnd(), 235+15*rnd()];     // near white-blue
  const warmSun= [255, 240-20*rnd(), 220-30*rnd()];              // warm highlight
  const waterDeep=[18+12*rnd(), 92+35*rnd(), 105+45*rnd()];      // teal/blue-green
  const waterShal=[80+40*rnd(), 170+40*rnd(), 170+35*rnd()];     // clearer shallows

  // clouds
  const cloudScale=1.2+2.2*rnd();
  const cloudCover=0.48+0.12*rnd();      // lower => more clouds
  const cloudSoft =0.10+0.18*rnd();
  const cloudBold =0.85+0.45*rnd();

  // waves: sum of directional sines + micro ripples (no “平移贴图”)
  const w1=0.9+0.9*rnd(), w2=1.2+1.1*rnd(), w3=1.6+1.2*rnd();
  const dir1=rnd()*Math.PI*2, dir2=rnd()*Math.PI*2, dir3=rnd()*Math.PI*2;
  const amp =0.030+0.040*rnd();          // normal strength
  const micro=0.010+0.020*rnd();
  const speed=0.20+0.25*rnd();

  // lighting
  const sunAng = -0.8 + 1.6*rnd();       // sun direction azimuth
  const sunEl  = 0.35 + 0.45*rnd();      // elevation
  const fres   = 0.06 + 0.06*rnd();      // base reflectance
  const clarity= 0.72 + 0.22*rnd();      // clear water amount (less haze)
  const caust  = 0.18 + 0.25*rnd();      // caustic strength

  scene={seed:seedBase,skyTop,skyHzn,warmSun,waterDeep,waterShal,
    cloudScale,cloudCover,cloudSoft,cloudBold,
    w1,w2,w3,dir1,dir2,dir3,amp,micro,speed,
    sunAng,sunEl,fres,clarity,caust,score:0};
}
newScene();

// ---- Sky + clouds sampling in "sky UV" (u,v in [0,1]) ----
function skyColor(u,v,t){
  // v=0 top, v=1 horizon
  const g=smoothstep(0,1,v);
  let col=mix3(scene.skyTop, scene.skyHzn, g);

  // soft sun glow near some spot in sky
  const su=0.62 + 0.10*Math.cos(scene.sunAng);
  const sv=0.20 + 0.10*(1-scene.sunEl);
  const dx=u-su, dy=v-sv;
  const r=Math.sqrt(dx*dx + dy*dy);
  const glow=Math.exp(-r*r*8.0);
  col=mix3(col, scene.warmSun, glow*0.18);

  // clouds (evolving field: time enters noise, not translate)
  const X=(u-0.5)*scene.cloudScale*2.4;
  const Y=(v-0.35)*scene.cloudScale*2.0;
  const tt=t*0.035;

  // domain warp for natural evolution
  const wA=fbm(X*0.8+3.1+tt, Y*0.8+7.9, scene.seed+11);
  const wB=fbm(X*0.8+9.7, Y*0.8+1.6+tt*1.3, scene.seed+23);
  const wx=(wA-0.5)*0.55, wy=(wB-0.5)*0.55;

  const n=fbm(X+wx+tt*0.6, Y+wy+tt*0.8, scene.seed+101);
  // coverage + softness
  const c = smoothstep(scene.cloudCover, scene.cloudCover+scene.cloudSoft, n);
  const puff = Math.pow(c, 1.1) * scene.cloudBold;

  // cloud lighting: slightly warm on lower part
  const lit = (0.85 + 0.15*(1-v)) * (0.85 + 0.15*glow);
  const cloudCol = mix3([255,255,255], scene.warmSun, 0.10) ;

  // composite (soft)
  col = mix3(col, mix3(coloudSafe(cloudCol), [255,255,255], 0.06), puff*0.85*lit);
  return col;

  function coloudSafe(a){return [a[0],a[1],a[2]];}
}

// ---- Water waves -> normal (procedural, no tiling “饼干队列”) ----
function waveHeight(x,y,t){
  // x,y in "water space"
  const tt=t*scene.speed;
  const ax=Math.cos(scene.dir1), ay=Math.sin(scene.dir1);
  const bx=Math.cos(scene.dir2), by=Math.sin(scene.dir2);
  const cx=Math.cos(scene.dir3), cy=Math.sin(scene.dir3);

  const h =
    Math.sin((x*ax + y*ay)*scene.w1 + tt*1.2)*0.55 +
    Math.sin((x*bx + y*by)*scene.w2 - tt*1.0)*0.35 +
    Math.sin((x*cx + y*cy)*scene.w3 + tt*0.8)*0.25;

  // micro ripples (time enters noise)
  const m = fbm(x*0.9+tt*0.7, y*0.9-tt*0.6, scene.seed+333);
  return h*0.65 + (m-0.5)*1.1;
}

function waterNormal(x,y,t){
  // finite diff
  const e=0.015;
  const h = waveHeight(x,y,t);
  const hx= waveHeight(x+e,y,t);
  const hy= waveHeight(x,y+e,t);
  let nx = (h - hx)/e;
  let ny = (h - hy)/e;
  // mix macro + micro strength
  nx *= scene.amp; ny *= scene.amp;
  // add tiny micro normal from higher freq
  const m = fbm(x*2.2+t*0.25, y*2.2-t*0.22, scene.seed+777)-0.5;
  nx += m*scene.micro; ny += m*scene.micro;
  // normalize
  const nz=1.0;
  const inv=1/Math.sqrt(nx*nx+ny*ny+nz*nz);
  return [nx*inv, ny*inv, nz*inv];
}

// ---- Render: clear water with cloud reflection + Fresnel + specular + caustics ----
function render(t){
  const invW=1/OW, invH=1/OH;

  // sun direction in view space
  const sx=Math.cos(scene.sunAng)*Math.cos(scene.sunEl);
  const sy=Math.sin(scene.sunAng)*Math.cos(scene.sunEl);
  const sz=Math.sin(scene.sunEl);

  let p=0;
  for(let j=0;j<OH;j++){
    const v=j*invH;            // 0 top
    for(let i=0;i<OW;i++){
      const u=i*invW;

      // view ray (approx): screen -> water plane (we assume camera above looking down a bit)
      // use v to simulate “distance”: top=far horizon, bottom=near
      const dist = 0.35 + 2.2*Math.pow(v, 1.15);
      const x = (u-0.5)*dist*3.2;
      const y = (v-0.2)*dist*3.0;

      const n = waterNormal(x,y,t);
      const nx=n[0], ny=n[1], nz=n[2];

      // fresnel (Schlick)
      const Vz=1.0; // view approx pointing along +z
      const ndv = clamp(nz*Vz, 0, 1);
      const F0 = scene.fres;
      const fres = F0 + (1-F0)*Math.pow(1-ndv, 5);

      // reflection UV in sky space: perturb by normal (looks like refraction of reflection)
      // stronger distortion near bottom (near camera)
      const distort = (0.05 + 0.22*Math.pow(v,1.2));
      let ru = u + nx*distort;
      let rv = (1 - v) + ny*distort*0.9;    // mirror vertically
      // clamp
      ru=clamp(ru,0,1); rv=clamp(rv,0,1);

      // reflected sky+clouds
      const sky = skyColor(ru, rv*0.72, t); // compress sky height => more reflection "water-like"

      // water body color via Beer-Lambert (depth varies with distance + noise)
      const depth = clamp(0.25 + 1.35*Math.pow(v,1.25) + (fbm(x*0.25+2.2,y*0.25-1.7,scene.seed+909)-0.5)*0.25, 0, 2.2);
      const k = lerp(1.8, 0.9, scene.clarity); // clarity reduces absorption
      const absorb = Math.exp(-depth*k);
      const waterBase = mix3(scene.waterDeep, scene.waterShal, clamp(absorb*1.1,0,1));

      // “underwater” caustics (subtle, higher near top-middle)
      const ca = Math.pow(Math.max(0,
        Math.sin((x*1.8 + t*0.8)) + Math.sin((y*2.1 - t*0.7)) + Math.sin((x+y)*1.4 + t*0.6)
      )*0.33, 2.2);
      const caAmt = scene.caust * ca * (0.45+0.55*(1-v)) * (0.25+0.75*absorb);

      // specular highlight (sun glint)
      // half vector approx with view=(0,0,1)
      const hx=sx, hy=sy, hz=sz+1; // sun + view
      const hinv=1/Math.sqrt(hx*hx+hy*hy+hz*hz);
      const Hx=hx*hinv, Hy=hy*hinv, Hz=hz*hinv;
      const ndh=clamp(dot(nx,ny,nz,Hx,Hy,Hz),0,1);
      const spec = Math.pow(ndh, 220*(0.6+0.4*(1-v))) * 1.2; // tighter far away
      const specCol = mix3(scene.warmSun, [255,255,255], 0.35);

      // final composite:
      // reflect + transmit (clear water) + caustics + spec
      let col = mix3(waterBase, sky, fres*1.15);
      col = mix3(col, [255,255,255], caAmt*0.18); // caustics brighten
      col = mix3(col, specCol, spec*0.85);

      // tiny “surface sparkle” micro-roughness (prevents plasticky)
      const sparkle = Math.pow(clamp(fbm(x*1.6+t*0.15, y*1.6-t*0.12, scene.seed+606),0,1), 5.5) * 0.06;
      col = mix3(col, [255,255,255], sparkle);

      // very light vignette
      const dx=u-0.5, dy=v-0.55;
      const vv = clamp(1 - (dx*dx*1.8 + dy*dy*2.2), 0, 1);
      const vfac = 1 - 0.08*(1-vv);
      col = [col[0]*vfac, col[1]*vfac, col[2]*vfac];

      data[p++]=col[0]|0; data[p++]=col[1]|0; data[p++]=col[2]|0; data[p++]=255;
    }
  }
  octx.putImageData(img,0,0);
  ctx.save();
  ctx.imageSmoothingEnabled=true;
  ctx.clearRect(0,0,W,H);
  ctx.drawImage(off,0,0,OW,OH,0,0,W,H);
  ctx.restore();
}

// ---- Grain dithering (kills iOS banding) ----
const grain=document.createElement("canvas");
const gctx=grain.getContext("2d",{alpha:true});
let gpat=null;
function buildGrain(seed){
  const N=256; grain.width=grain.height=N;
  const im=gctx.createImageData(N,N), d=im.data;
  let s=seed>>>0;
  const rnd=()=>((s=(s*1664525+1013904223)>>>0)&0xfffffff)/0xfffffff;
  for(let i=0;i<d.length;i+=4){
    const r=rnd();
    const v=(r<0.5? r*r : 1-(1-r)*(1-r));
    const n=v-0.5;
    const a=clamp(9 + Math.abs(n)*30, 8, 40);
    d[i]=255; d[i+1]=255; d[i+2]=255; d[i+3]=a;
  }
  gctx.putImageData(im,0,0);
  gpat=null;
}
buildGrain(scene.seed^0x9e3779b9);

function drawGrain(t){
  if(!gpat) gpat=ctx.createPattern(grain,"repeat");
  ctx.save();
  ctx.globalAlpha=0.045*(0.92+0.08*Math.sin(t*2.0));
  ctx.fillStyle=gpat;
  const ox=(Math.sin(t*0.9)*3)|0, oy=(Math.cos(t*1.1)*3)|0;
  ctx.translate(ox,oy);
  ctx.fillRect(-10,-10,W+20,H+20);
  ctx.restore();
}

// ---- switch / auto ----
function applyScene(){
  newScene();
  buildGrain(scene.seed^0x9e3779b9);
}
function switchNow(){ applyScene(); clearInterval(auto); auto=setInterval(switchNow,60*1000); }
BTN.addEventListener("click",switchNow);
let auto=setInterval(switchNow,60*1000);

// ---- main loop + adaptive quality ----
let t=0,last=performance.now(),ema=60;
function tick(now){
  requestAnimationFrame(tick);
  const dt=now-last; last=now;
  const fps=1000/(dt||16.7); ema=ema*0.92+fps*0.08;
  t += dt*0.001;

  // adaptive q for iOS smoothness
  const target=mobile?60:90;
  if(ema<target*0.92){ q=clamp(q*0.985, mobile?0.30:0.32, 0.55); alloc(); }
  if(ema>target*1.06){ q=clamp(q*1.004, mobile?0.30:0.32, 0.55); alloc(); }

  render(t);
  drawGrain(t);

  if(((now/400)|0)%2===0){
    S.textContent=`fps~${ema.toFixed(0)} · q ${q.toFixed(2)} · clouds reflect · water clear`;
  }
}

resize();
requestAnimationFrame(tick);

}catch(e){showErr(e);}
})();
</script>